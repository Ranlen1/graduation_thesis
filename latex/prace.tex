%šablona pro maturitní práci Gymnázia Jírovcova 8, České Budějovice
% Autoři šablony: Jonáš Havelka, Michal Kočer, Daniel Sýkora
% Typ dokumentu: report
% veškeré úpravy v soubor MP.sty (styl maturitní práce)
\documentclass[12pt]{report}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{config}						  % Import stylu maturitní práce
\author{René Čakan}                  % AUTOR PRÁCE
\title{Programování grafické aplikace v C++}    % NÁZEV PRÁCE
\date{6. února 2026}                 % DATUM ODEVZDÁNÍ PRÁCE
\vedouci{Dr. rer. nat. Michal Kočer} % VEDOUCÍ PRÁCE
\place{V Českých Budějovicích}
\skolnirok{2025/2026}                  % ŠKOLNí ROK
\logo{\includegraphics[scale=1.25]{GJ8_logotyp}} %Logo školy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document} %%%%%%% začátek dokumentu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Titulní stránka + úvodní povinné stránky
\pagenumbering{roman}                   % číslování stránek římskými číslicemi
	\mytitlepage						% Vygenerování titulní strany
	
	\prohlaseni{
		Prohlašuji, že jsem tuto práci vypracoval samostatně s vyznačením všech použitých pramenů.
	}	
	
	\abstrakt{
	}{
	}
	
	\podekovani{
	}
	
   {\tableofcontents\newpage}			% Obsah
	
\addtocounter{page}{1}		% Posunutí countru stránek
\pagenumbering{arabic}		% Číslování stránek arabskými číslicemi
\chapter*{Úvod}     % úvod práce 
\addcontentsline{toc}{chapter}{Úvod}

%%%%%%%%%%%%%% TEORETICKÁ ČÁST %%%%%%%%%%%%%%%%%%	
\part{Teorie k vývoji hry v OpenGL}  % název teoretické části (nenechávejte Teoretická část)
	
\chapter{Programovací jazyky}
			
\section{Programovací jazyk C}
    C je středněúrovňový programovací jazyk, tedy jazyk, který je podobou blízko strojovému kódu,
    ale má už prvky vyššího programovacího jazyka jako jsou funkce, datové struktury nebo to že je
    strukturovaný. Je kompilovaný a statický, což znamená, že se program musí nejdříve přeložit do
    strojového kódu a až pak se může spustit. Datové typy jsou známy v čase kompilace, proto všechny
    proměnné musí být v kódu deklarovány, jelikož vkládání vstupních dat do programu probíhá až při
    běhu programu. Programuje se v něm strukturovaně a procedurálně, tedy kód se píše pomocí
    řídících struktur (if, while, for atd.) a pomocí funkcí, které umožňují používat části
    kódu vícekrát. C nemá automatický správce paměti, takže je potřeba uvolňovat paměť manuálně. C
    má střídmou standardní knihovnu, která obsahuje základní matematické operace a funkce pro
    práci s pamětí a soubory, takže jakékoliv složitější datové struktury či funkce si člověk musí
    naprogramovat sám. Tato strohost a blízkost ke strojovému kódu z C dělá jeden z nejrychlejších
    programovacích jazyků.
    \cite{programming_in_c, the_c_programming_language, features_of_C,
    low-level_midlvel_and_high-level_language, structured_programming}

    C bylo vytvořeno Dennisem Ritchiem na počátku 70. let 20. století v AT\&T Bell Labs 
    Jeho předchůdci byly jazyky ALGOL, CPL, BCPL a B. Jeho prvotním účelem bylo
    přepsat operační systém UNIX do použitelnějšího jazyka než Assembly a B. Už koncem 70. let bylo
    C populární, ale nebylo standardizované a vznikalo mnoho různých variant. Na začátku 80. let
    tedy American National Standards Institute (ANSI) zahájil práci na formální standardizované
    verzi. Tu dokončili v roce 1989 a je známa pod jménem C89. V průběhu let vycházely další verze,
    které jazyk zlepšovaly a modernizovali. Nejdůležitější verze byly C99, C11 a C17. Norma C23 byla
    nedávno schválena a teď se implementuje do kompilátorů. V součastnosti mezi nejpoužívanější
    kompilátory patří GCC, Clang a MSVC. Jelikož bylo C velice populární,
    ovlivnilo řadu jiných programovacích jazyků, jako C\+\+, C\#, Java, Rust, Go atd.
    \cite{the_c_book:_featuring_the_ansi_c_standart, c_a_reference_manual,
    programming_in_c, the_c_programming_language}

    C je univerzální programovací jazyk, má tedy širokou škálu využití. Jeho první využití bylo k
    napsání UNIXu, který později ovlivnil operační systémy jako Linux, macOS, iOS a Android.
    Používá se v programování softwaru s omezenou pamětí a výkonem, jako je firmware aut či v
    zařízeních chytrých domácností. Dále se využívá pro tvoření kompilátorů a interpreterů jako je
    GCC nebo interpreter Pythonu. Také jsou v něm napsané systémové databáze MySQL a Oracle
    Database. Kvůli jeho rychlosti jsou v něm napsané knihovny pro jiné programovací jazyky jako je
    NumPy, OpenGL či GLFW.
    \cite{the_c_book:_featuring_the_ansi_c_standart, programming_in_c,
    top_applications_of_c_programming}

    Jednoduchý program, který načte ze vstupu počet čísel, která chce uživatel setřídit. Následně
    daná čísla načte a vytiskne je seřazená:

\begin{lstlisting}[caption={sort\_n\_numbers.c}]
#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}

int main(void)
{
    int sizeOfArray;
    scanf("%d", &sizeOfArray);
    int *array = malloc(sizeOfArray *sizeof(int));

    for(int i = 0; i < sizeOfArray; ++i)
        scanf("%d", &array[i]);

    qsort(array, sizeOfArray, sizeof(int), compare);

    for(int i = 0; i < sizeOfArray; ++i)
        printf("%d\n", array[i]);

    free(array);
    return 0;
}
\end{lstlisting}

\section{Programovací jazyk C++}
    Programovací jazyk C++ je v mnoha ohledech podobný jazyku C. Je stejně jako C středně\-úrovňový,
    kompilovaný, statický, má datové typy známé v době kompilace a nemá automatický správce
    paměti. V C++ se také programuje strukturovaně a procedurálně, ale na rozdíl od C, také umožňuje
    programovat objektově. Objektové programování umožňuje používat objekty, které jsou instance
    tříd. Tyto třídy umožňují dědičnost, polymorfismus a zapouzdření, což
    dělá kód přehlednější a usnadňuje budoucí rozšiřování a debuggování. 
    Dalším rozdílem je standardní knihovna, kterou má C++ rozsáhlejší.
    Obsahuje nové kontejnery jako vector, map, a priority\_queue, které jsou tvořeny pokročilejšími
    datovými strukturami jako binární vyhledávací strom nebo heap. Dále obsahuje nové algoritmy,
    například sort, find nebo count. Kvůli velké podobnosti C a C++ se často může C kód používat v
    C++, ale není tomu tak vždy. Například tento kód:
\begin{lstlisting}[caption={incompatibility\_example.c}]
int class(int new, int bool); 
\end{lstlisting}
    V C tento kód vytvoří funkci class, která vrací int a má dva parametry new a bool. V C++ jsou ale
    class, new a bool klíčová slova, která nelze použít v názvu proměnných a funkcí. Pokud chce
    programátor napsat C kód, který se bude jednoduše v C++ programech,
    doporučuje se programovat v C tak, aby daný C kód byl podmnožinou C++.
    \cite{the_cpp_programming_language, programming_principles_and_practice_using_cpp}

    C++ bylo vytvořeno Bjarnem Stroustrupem v roce 1979 v AT\&T Bell Labs. Před 
    vytvořením C++ pracoval Stroustrup s programovacím jazykem Simula 67, který byl
    objektově orientovaný a sloužil primárně k vytváření simulací. Stroustupovi přišlo
    objektově orientované programování
    velmi užitečné, ale Simula 67 byl příliš pomalý pro větší projekty. Rozhodl
    se vytvořit nadmnožinu jazyka C, která by umožňovala objektově orientované programování a zároveň
    si zachoval rychlost C, s názvem C with Classes. V roce 1982 byl Stroustrup se stavem C with
    Classes zklamán. Nepřišlo mu, že oproti C přináší významné zlepšení a rozhodl se jazyk dále
    vylepšovat nad rámec objektově orientovaného programováni. V roce 1983 byl jazyk přejmenován z
    C with Classes na C++. Dále bylo C++ v roce 1985 oficiálně 
    vydáno a začalo se používat komerčně. V roce 1998 byla
    vydána první standardizovaná verze s jménem C++98. Další významné verze, které jazyk
    modernizovaly a přidávaly mu nové funkce, byly C++03, C++11, C++14, C++17, C++20 a
    nejnovější verze C++23. C++ se kompiluje pomocí stejných kompilátorů jako C, tedy GCC, Clang
    a MSVC.
    \cite{programming_principles_and_practice_using_cpp, design_and_evolution_cpp, history_of_cpp, cpp_computer_language}

    C++ je stejně jako C univerzální programovací jazyk, a využívá se v široké škále odvětví. První
    využití je ve videoherním průmyslu. V C++ jsou napsané populární hrací enginy jako Unity nebo
    Unreal Engine. Dále se v něm vytváří aplikace jako Photoshop nebo Blender. Využívá se v částech
    operačních systémů jako Apple macOS nebo Microsoft Windows OS. Dále se využívá při vytváření 
    internetových prohlížečů, například Firefox nebo Google Chrome. C++ se využívá i ve vědě,
    například v CERNu nebo v NASA. 
    \cite{the_cpp_programming_language, top_25_cpp_applications_in_real_world, what_is_cpp_used_for}

    Program se stejnou funkcí jako z kapitoli o C, ale napsán v C++
\begin{lstlisting}[caption={sort\_n\_numbers.cpp}]
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    int sizeOfArray;
    std::cin >> sizeOfArray;
    std::vector<int> arr(sizeOfArray);

    for(int i = 0; i < sizeOfArray; ++i)
        std::cin >> arr[i];

    std::sort(arr.begin(), arr.end());

    for(int i : arr)
        std::cout << i << '\n';

    return 0;
}
\end{lstlisting}


    
\clearpage
\chapter{Počitačová grafika}			
\section{Grafické karty}
\subsection{CPU vs. GPU}
    Tradičně běžela většina apklikací sekvenčně, které běží na procesorech, které
    mají centrální výpočetní jednotku a provádí instrukce
    jednu po druhé \gls{cpu}. V průběhu 20. století se výkon \gls{cpu} významě zlepšoval až na
    bilion operací za sekundu, čímž se mohli zlepšévat grafické aplikace a využívat náročnější
    funkce. Na přelomu tisíceletí se ale vývoj začal zpomalovat, kvůli problému se spotřebou
    energie a odvodem tepla. Proto výrobci začali vytvářet \gls{cpu} s více jádry, ale ani to nebylo
    dostatečně výkonné na složíté výpočti, a proto už v sedmdesátých a osmdesátých
    letech začali vznikat počítače které nepracovali sekvenčně, ale paralelně. V devadesátých
    letech se
    začali vytvářet mikroprocesory, které se soustředili na paralelní výpočty \gls{gpu}. V průběhu
    let se počet jader z jednotek dostal na tisíce, což vytvořilo prostor pro inovaci v grafice.
    \cite{programming_massively_parallel_processors}

    Prvně bylo \gls{gpu} pouze v počítačích specializovaných pro 3D hry a vizualizace, ale postupně
    se stala součástí každého počítače. \gls{gpu} a \gls{cpu} se používá v různých případech kvůli
    rozdílné architektuře. \gls{cpu} má jednotky až desítky jader a umí dělat jeden krok extrémě
    rychle kvůli sekvenčnímu zapojení.
    Velká část čipu je určena pro cachi, tedý malu pamět, kam se ukládají data která budou 
    pravděpodobně v budoucnisti potřeba, takže není potřeba komunikovat neustále s \gls{ram}.
    Část čipu je také pro control logiku, která dokáže instrukce z jednoho vlákna dělat paralelně
    nebo na jiném sekvenčním pořadí, ale zachovat sekvenčnost celého procesu. \gls{cpu} má také
    menší propustnost paměti než \gls{gpu}, proto jsou cache-friendly programy výrazně rychlejší.
    Narozdíl od toho má \gls{gpu} stovky až tisíce jader.
    Kontrolní logika a cache jsou v jádru menší a jednodužší, 
    takže velmi pomalu reaguje na
    události a po dokončení operaí se většinou data vrací zpět do virtual random access memory
    \gls{vram}, což je díky velké
    propustnosti i pro velmi velký objem dat rychlé.
    \cite{programming_massively_parallel_processors}

    Do roku 2007 se \gls{gpu} používalo převážně pro renderování, ale v roce 2007 přišla NVIDIA s
    programovacím modelem pro paralelní výpočty CUDA. Tento model umožňuje psát programy, které běží
    na \gls{gpu} a využívají \gls{cpu} na přenos dat a řízení těchto programů. Díky tomu mohly začít
    vznikat aplikace, které normálně běží na \gls{cpu}, ale při potřebě náročnějších početních
    operací mohly běžet na \gls{gpu}, a tím zvýšit výkon. Pro účel vysvětlení programovacích modelů
    pro paralelní výpočty budu využívat model CUDA, přičemž existují i jiné podobné modely jako
    OpenCL nebo SYCL. 
    \cite{programming_massively_parallel_processors}

\subsection{Architektura a paměťová hierarchie GPU}

    \gls{gpu} s podporou CUDA je organizováno do pole paralelních streamovacích multiprocesorů
    \gls{sm}. Každý \gls{sm} se skládá z několika streamovacích procesorů \gls{sp}, které jsou
    základní výpočetní jednotkou, na které probíhají aritmetické operace. Další součástí jsou řídicí
    jednotky, které načítají instrukce pro daný \gls{sm}. Řídicí jednotky také obsahují malou cache
    na instrukce, aby se pro ně nemuselo pořád sahat do \gls{ram}. Dále je uvnitř \gls{sm} warp
    scheduler, který řídí, které skupiny vláken budou v každém cyklu použity.
    \cite{programming_massively_parallel_processors}

    Většina grafických karet má svoji vlastní dynamic random access memory \gls{dram}, které se říká
    globální paměť. V grafických kartách je specifický typ \gls{dram} zvaný \gls{vram}. Tato paměť má
    jednotky až desítky gigabytů. Dochází v ní k výměně dat mezi host memory a \gls{vram}.Tato rychlá
    výměna dat je zaručena velkou propustností, která je způsobena načítáním dat blokově namísto
    sekvenčně a také posíláním většího objemu dat najednou. \gls{vram} je sdílena mezi všemi \gls{sm},
    ale přístup k ní je relativně pomalý. Další pamětí je shared memory, která má většinou desítky
    kilobajtů. Tuto paměť má každý \gls{sm} a každý \gls{sp} si do ní může sahat. V každém \gls{sm}
    se také vyskytuje L1 cache, která slouží k uchovávání dat, ze kterých se nedávno četlo nebo byla
    změněna. Dále existuje L2 cache, která je větší než L1 cache a je jedna pro všechny \gls{sm}.
    Používá se pro uchovávání dat nedávno získaných nebo poslaných do \gls{vram}. Část \gls{vram} je
    také určena pro dva jiné typy paměti, a to texture a constant memory. Obě paměti mají k sobě
    přiřazenou svoji cache a jsou read-only. Tím, že jsou read-only, můžeme často používané hodnoty
    uchovávat v cache bez obavy z toho, že by se daná proměnná mohla v průběhu změnit. Nejmenší, ale
    také nejrychlejší částí paměti jsou register files. Tato paměť přímo komunikuje s \gls{sp} a
    ukládají se do ní dočasné proměnné a mezivýpočty.
    \cite{programming_massively_parallel_processors, memory_hierarchy_of_gpu, memory_types_of_gpu}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{GPU_architecture.png}
        \caption{Typická architektura NVIDIA \gls{gpu} \cite{gpu_image_source}} 
    \end{figure}

\subsection{Paralelismus}
    Paralelismus je výpočetní technika, která umožňuje vykonávání více operací najednou. Paralelismus
    se dá rozdělit do dvou kategorií. První z nich je úlohový paralelismus. Tento typ následuje
    Multiple Instructions, Multiple Data (MIMD) model. Tento model rozdělí různé úlohy mezi více
    vláken nebo i jader. Tento model se využívá, pokud na sobě nejsou úlohy závislé. Pokud by se
    například chtěla vypočítat suma vectoru, může každé vlákno počítat jednu polovinu a oba výsledky
    sečíst. MIMD se využívá v simulacích nebo ve webových aplikacích.
    \cite{programming_massively_parallel_processors, types_of_parallelism}

    Druhou metodou je datový paralelismus, který je definován Single Instruction, Multiple Data (SIMD)
    modelem. Tento model aplikuje jednu úlohu pro velké množství dat a využívá se v \gls{gpu}.
    Používá se například při násobení matic, kde se daná matice dá rozdělit na menší části, nebo při
    vykreslování, kdy se jeden shader aplikuje pro každý pixel. V grafických kartách se jednotlivá
    vlákna sdružují do warpů, ty dále do bloků, které plánuje \gls{sm}. Do každého warpu jsou načteny
    stejné instrukce a postupně se mu dodávají data, na kterých dané instrukce provádí. Díky tomu lze
    i velké množství dat zpracovat velmi rychle, protože se dodávají s velkou propustností a
    instrukce na nich jsou prováděny současně na velkém množství warpů.
    \cite{programming_massively_parallel_processors, types_of_parallelism}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{vlakna_v_sm.png}
        \caption{Rozdělení vláken do warpů v \gls{sm} \cite{programming_massively_parallel_processors}} 
    \end{figure}

\section{Grafická zobrazovací pipeline}
    Hlavní funkcí grafické zobrazovací pipeline je vyrenderovat dvourozměrný obraz z trojrozměrných
    objektů, pozice virtuální kamery, zdrojů světla atd., který je schopen být zobrazen například na
    monitoru. Pipeline se skládá z několika fází. Tyto fáze probíhají paralelně jak v rámci
    jednotlivých fází (tedy jedna fáze probíhá pro více dat najednou), tak i mezi jednotlivými
    fázemi, takže po průchodu jednoho bloku dat jednou fází data přecházejí do další fáze, i když pro
    jiná data ještě předchozí fáze nemusí být ukončena. Hlavní čtyři fáze jsou aplikační fáze,
    geometrické zpracování, rasterizace a zpracování pixelů.
    \cite{real_time_rendering}

    Aplikační fáze je řízena samotnou aplikací a je většinou implementována jako software běžící na
    \gls{cpu}. Tato fáze nemá žádné podprvky, a proto může běžet paralelně na různých jádrech. V této
    části se zpracovávají vstupy od uživatele, které například pozměňují matici k posunutí, otočení
    nebo změně velikosti různých objektů. V této části také dochází k detekci kolizí, akceleračním
    algoritmům, fyzikální simulaci a dalším výpočtům, které připravují data pro další scénu.
    \cite{real_time_rendering}

    Další částí pipeline je geometrické zpracování. Ta je zodpovědná za většinu operací pro každý
    trojúhelník a vrcholy, které tvoří objekty. Rozděluje se na čtyři podfáze: vertex shading,
    projekce, clipping a screen mapping. Vertex shading vypočítává pozici vrcholu a připravuje jeho
    data, jako barvy a textury. Objekt je transformován z modelového prostoru do světových souřadnic,
    tedy souřadnic relevantních pro všechny objekty ve scéně. Dále se transformuje do kamerového
    prostoru, ve kterém je kamera v bodě nula. Poté dochází k projekci, kdy dochází k transformaci z
    kamerového prostoru do clip spacu, aby bylo možné provést clipping. Clipping určuje, jaké objekty
    se budou renderovat. Pokud by například celý objekt byl mimo zorné pole scény, není renderován,
    aby zbytečně nezatěžoval \gls{gpu}. Poslední částí je mapování na obrazovku, které převede
    souřadnice z clip spacu do souřadnic obrazovky připravených pro rasterizaci. Součástí vertex
    shadingu jsou také volitelné fáze vertex zpracování. Tessellation generuje vhodné trojúhelníky
    pro zakřivené povrchy, aby vypadaly realističtěji. Geometry shader umožňuje podle potřeby
    vytvářet nové vrcholy z existujících trojúhelníků nebo bodů, což se používá například u malých
    částic, aby byly lépe vidět na obrazovce, takže se z nich udělá například malý čtverec. Poslední
    volitelná fáze je stream output, která umožňuje namísto poslání vrcholu do další fáze uložit
    vrcholy do bufferu, na kterých \gls{cpu} může dělat další výpočty či simulace.
    \cite{real_time_rendering}

    Následující fáze je rasterizace, jejímž účelem je nalézt všechny pixely uvnitř vykreslovaného
    trojúhelníku. Rasterizace se dělí na přípravu trojúhelníku a průchod trojúhelníkem. Při přípravě
    se vypočítávají diferenciály, rovnice hran a jiná podobná data, která jsou využívána ke
    zjišťování, zda daný pixel leží uvnitř trojúhelníku. Při průchodu se zjišťuje, zda střed pixelu
    leží uvnitř trojúhelníku, a pokud ano, vytvoří se pro daný pixel fragment. Vlastnosti jako barva,
    hloubka atd. jednotlivých fragmentů se získávají interpolací mezi vrcholy daného trojúhelníku a
    následně se ukládají do specifických bufferů. Výsledné fragmenty jsou následně předány do fáze
    pixelového zpracování.
    \cite{real_time_rendering}

    Pixelové zpracování se dělí na pixelové stínování a slučování. Ve fázi pixelového stínování se
    provádějí výpočty stínování jednotlivých pixelů ze stínovacích dat. Výsledkem je jeden nebo více
    barevných výstupů. V této fázi se používá hodně specifických technik, jako například texturování.
    Pixelové stínování je na rozdíl od ostatních fází, které jsou dány architekturou \gls{gpu}, dáno
    programovatelnými jádry \gls{gpu}. Při slučování dochází ke kombinaci výstupu pixelového
    stínování a uložených barev v bufferech. V této fázi se také řeší viditelnost, aby se vykresloval
    pro daný pixel fragment s nejmenší hloubkou.
    \cite{real_time_rendering}

\section{Transformace}
    V průběhu renderování je často potřeba s objekty různě pohybovat. Mohli bychom pozměňovat
    souřadnice původních vrcholů a opětovně konfigurovat jejich buffery, ale to je výpočetně náročné.
    Místo toho se využívají transformace pomocí matic. Matice jsou obdélníková pole matematických
    výrazů. Souřadnice objektů se ukládají do 4D vektorů a transformace do 4x4 matic, které se mezi
    sebou vynásobí.
    \cite{learn_opengl}
    $$
    \begin{pmatrix}
    m_{00} \cdot x + m_{01} \cdot y + m_{02} \cdot z + m_{03} \cdot w \\
    m_{10} \cdot x + m_{11} \cdot y + m_{12} \cdot z + m_{13} \cdot w \\
    m_{20} \cdot x + m_{21} \cdot y + m_{22} \cdot z + m_{23} \cdot w \\
    m_{30} \cdot x + m_{31} \cdot y + m_{32} \cdot z + m_{33} \cdot w \\
    \end{pmatrix}
    =
    \begin{pmatrix}
    m_{00} & m_{01} & m_{02} & m_{03} \\
    m_{10} & m_{11} & m_{12} & m_{13} \\
    m_{20} & m_{21} & m_{22} & m_{23} \\
    m_{30} & m_{31} & m_{32} & m_{33}
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    w
    \end{pmatrix}
    $$
    Mezi základní operace patří translace, rotace a škálování. Translace je operace, při které se k
    původnímu vektoru přičte jiný vektor, čímž se původní objekt posune. Potřebujeme translační
    hodnoty násobit složkou w vektoru, která je nastavena na 1, aby neupravila tyto hodnoty. Proto
    používáme 4D vektor, protože s 3D vektorem by translace nebyla možná.
    $$
    \begin{pmatrix}
    x + T_{x} \\
    y + T_{y} \\
    z + T_{z} \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    1 & 0 & 0 & T_{x} \\
    0 & 1 & 0 & T_{y} \\
    0 & 0 & 1 & T_{z} \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    Další operací je škálování. Při této operaci se dané souřadnice násobí konstantou, čímž se může
    daný objekt zmenšit nebo zvětšit.
    $$
    \begin{pmatrix}
    S_{x} \cdot x \\
    S_{y} \cdot y \\
    S_{z} \cdot z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    S_{x} & 0 & 0 & 0 \\
    0 & S_{y} & 0 & 0 \\
    0 & 0 & S_{z} & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    Poslední důležitá operace je otáčení. Při této operaci závisí na tom, podle jaké osy se má objekt
    otáčet a o kolik radiánů se má otočit.
    Rotace podle osy X:
    $$
    \begin{pmatrix}
    x \\
    \cos \theta \cdot y - \sin \theta \cdot z \\
    \cos \theta \cdot y + \cos \theta \cdot z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    1 & 0 & 0 & 0 \\
    0 & \cos \theta & -\sin \theta & 0 \\
    0 & \sin \theta & \cos \theta & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    
    Rotace podle osy Y:
    $$
    \begin{pmatrix}
    \cos \theta \cdot x + \sin \theta \cdot z \\
    y \\
    -\sin \theta \cdot x + \cos \theta \cdot z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    \cos \theta & 0 & \sin \theta & 0 \\
    0 & 1 & 0 & 0 \\
    -\sin \theta & 0 & \cos \theta & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    
    Rotace podle osy Z:
    $$
    \begin{pmatrix}
    \cos \theta \cdot x - \sin \theta \cdot y \\
    \sin \theta \cdot x + \cos \theta \cdot y \\
    z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    \cos \theta & -\sin \theta & 0 & 0 \\
    \sin \theta & \cos \theta & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$

    Při provádění transformací záleží na pořadí. Pokud je pro transformaci jednoho objektu více matic,
    pronásobí se matice mezi sebou a používá se výsledná matice. Při tvoření takové matice se ale
    postupuje v opačném pořadí násobení. Pokud bychom pro vektor V chtěli udělat operace a, b a c,
    tak to lze udělat následovně:
    $$ \mathbf{V'} = \mathbf{C} \cdot (\mathbf{B} \cdot (\mathbf{A} \cdot \mathbf{V})) $$
    nebo
    $$ \mathbf{M} = \mathbf{C} \cdot \mathbf{B} \cdot \mathbf{A} $$
    $$ \mathbf{V'} = \mathbf{M} \cdot \mathbf{V} $$

\chapter{OpenGL}
\section{Historie OpenGL}
OpenGL je považováno za Application Programming Interface \gls{api}, které uživatelům poskytuje sadu
funkcí, kterou můžeme používat k manipulaci s grafickou kartou. Specifikaci pro OpenGL tvoří
společnost Khronos Group, která určuje, jaké funkce existují a jak se budou chovat. Poté každá
společnost implementuje OpenGL API pro svůj druh grafických karet.
\cite{learn_opengl}

\section{OpenGL pipeline}
Grafická pipeline je velmi podobná obecné grafické pipeline, kterou jsem popisoval v předchozí
kapitole. Uživatel je schopen kontrolovat programovatelné fáze pipeline, tedy vertexový a fragmentový
shader. Části jako rasterizace jsou neměnné a jsou definované v API.
\cite{learn_opengl}

\section{Shadery}
\subsection{Co to je shader}
Shader je malý program, který běží na \gls{gpu}. Tyto programy se spouštějí pro konkrétní část
grafické pipeline. Shadery přeměňují vstupy a převádějí je na výstupy potřebné pro následující fáze.
Starší verze OpenGL měly defaultní shadery, ale v novějších verzích je uživatel povinen vytvořit
základní shadery, aby \gls{gpu} něco vykreslila. Shadery jsou od sebe izolované a komunikují spolu
pouze pomocí vstupů a výstupů. Shaderů je více druhů a dva základní jsou vertex a fragment shader.
Shadery se kompilují a linkují a následně ukládají do paměti \gls{gpu} jako součást shader programu.
To je objekt, který je výslednou slinkovanou verzí více shaderů. Shader programů může mít uživatel
více a pro každý objekt si může vybrat jiný podle toho, jaké shadery na něj chce použít.
\cite{learn_opengl}

\subsection{Vertex shader}
Základní účel vertex shaderu je zpracovávání vrcholů objektu. Do vertex shaderu vstupují atributy
vrcholů, jako barvy nebo 3D souřadnice bodů v modelovém prostoru. Vertex shader provádí transformace
těchto souřadnic do světového, kamerového a následně clip prostoru pomocí transformačních matic.
Vstupní data jsou uložena v \gls{gpu}, kde k nim má vertex shader přímý přístup.
\cite{learn_opengl}

\subsection{Fragment shader}
Účelem fragment shaderu je vypočítávání barevného výstupu pro pixely. Barvy se v OpenGL definují 4D
vektorem s floaty od 0.0 do 1.0. Tato čísla udávají sílu barev červená, zelená a modrá (RGB).
Poslední číslo udává alfa hodnotu, tedy jak moc kombinace daných tří barev bude průhledná. Ve
fragment shaderu také dochází k texturování a různým efektům, jako jsou odlesky, stínování atd.
\cite{learn_opengl}

\subsection{Buffery a linkování}
Vstupní data vertex shaderu se ukládají do paměti \gls{gpu} pomocí Vertex Buffer Objektu \gls{vbo}.
Ten v sobě dokáže uložit velké množství dat, díky čemuž jich posíláme více najednou a využíváme
vysokou propustnost \gls{gpu}. Tato data jsou pak jednoduše přístupná pro vertex shader, který s nimi
v \gls{gpu} pracuje. Následně se propojují vertex atributy. To udává, jak jsou vstupní data linknuta
k proměnným uvnitř vertex shaderu. Dalším důležitým objektem je Vertex Array Object \gls{vao}, do
kterého se ukládá, jak jsou data v VBO uspořádána a jak se mají propojit s vertex shadery.
\cite{learn_opengl}

Shadery se kompilují a linkují a následně ukládají do pameti \gls{gpu} jako součást shader programu.
To je objekt, který je výslednou slinkovanou verzí všech shaderů. Linkování shaderů propojuje výstupy
jednoho shaderu se vstupy druhého. Shader programů může mít uživatel více a pro každý objekt si může
vybrat jiný podle toho, jaké shadery na něj chce použít.
\cite{learn_opengl}

\subsection{GLSL}
Shadery se píší v programovacím jazyce OpenGL Shading Language \gls{glsl}, který je podobný jazyku C.
\gls{glsl} je specificky navržen pro práci s grafikou a obsahuje užitečné funkce na manipulaci s
vektory a maticemi. Pokud jsou na sebe linknuté dva shadery, výstupy z prvního shaderu se přenesou do
druhého shaderu. Proměnné ovšem musí mít identický typ a velikost. Další důležitou funkcí jsou
uniformy, což jsou globální proměnné pro všechny shadery uvnitř jednoho shader programu. V uniformách
se často uchovávají matice a další konstanty.
\cite{learn_opengl}

\section{Textury}
Textura je obrázek používaný k přidávání detailů k objektu. Pro každý vrchol objektu přiřadíme
souřadnici textury, která určuje, jaká část textury odpovídá danému vrcholu. Souřadnice textury se
ukládají do vertex atributů. Textura se pak aplikuje ve fragment shaderu na každý fragment objektu,
čímž se promítne. Je také možno mít původní barvu objektu s jednou nebo více texturami na jednom
objektu. Následně se barvy a textury poměrově mixují podle nastavených alpha hodnot.
\cite{learn_opengl}

\chapter{to do}
    mozna pridat trochu historie compileru u C a CPP

    kdyz introdusuju zkratku, dej ji velka pismena, at ctenar vi ze je to zkratka

    predelat pomlcky z - na tu dinvou co pouziva chat a chce ji pazi

    odendej vsechny cislovky z textu a nahrad je slovama

    mozna pridat ukazku vertex a fragment shaderu

%%%%%%%%%%%%%% PRAKTICKÁ ČÁST %%%%%%%%%%%%%%%%%%	
\clearpage
\part{Vývoj hry v OpenGL} % název praktické části (nenechávejte název Praktická část)
\chapter{Architektura hry}
Pro vytváření své hry jsem si vybral OpenGL, protože je to nízkoúrovňové \gls{api}, jehož použití
vyžaduje základní porozumění grafické pipeline. Jako programovací jazyk jsem si vybral C++, protože
je s C knihovnami dobře kompatibilní, ale přitom mohu využívat prvky objektově orientovaného
programování, které jsou ve vývoji hry užitečné.

Moje hra má dva základní stavy. Prvním z nich je menu, ve kterém se uživatel nachází při prvním
zapnutí hry. Po kliknutí na tlačítko „Play“ se uživatel přesouvá do druhého stavu běžící hry. Při
běhu hry je cílem hráče pohybovat košíkem a sbírat jablka, což přidává skóre. Zároveň je cílem hráče
vyhýbat se padajícím kokosům, které hráči odebírají životy. Tento stav běží, dokud uživateli nedojdou
všechny životy, a následně je přesunut zpět do herního menu. Hra je tvořena větším počtem souborů,
které níže vysvětlím.

\begin{itemize}
    \item \texttt{main.cpp} – Vytváří herní okno a spouští hlavní smyčky.
    \item \texttt{window.cpp} – Inicializuje GLFW a spravuje okno aplikace.
    \item \texttt{game.cpp} – Řídí přepínání herních stavů a resetuje proměnné při restartu hry.
    \item \texttt{game\_menu.cpp} – Renderuje stav menu a předává informaci do hlavní herní logiky,
        zda byla hra spuštěna.
    \item \texttt{game\_running.cpp} – Renderuje stav, kdy hra běží, a volá funkce pro objekty ve hře.
    \item \texttt{shader.cpp} – Spravuje shadery, tedy kompilaci, linkování, aktivaci a nastavování
        uniforem.
    \item \texttt{rendering\_function.cpp} – Poskytuje funkce pro načítání shaderů a propojování
        vstupních dat s \gls{vbo} a \gls{vao}.
    \item \texttt{texture.cpp} – Spravuje vytváření, aktivaci a nastavení parametrů textur.
    \item \texttt{vertices.cpp} – Uchovává vstupní data, jako jsou souřadnice objektů a textur.
    \item \texttt{fruit.cpp} – Spravuje tvoření, pohyb a mazání ovoce. 
    \item \texttt{player.cpp} – Spravuje pohyb hráče.
    \item \texttt{text.cpp} – Spravuje vytváření a aktualizaci textu pro počítání životů a bodů.
    \item \texttt{collision\_detection.cpp} – Zjišťuje, zda dochází ke kolizi hráče s ovocem, a
        případně volá aktualizaci životů a skóre.
    \item \texttt{random.cpp} – Vytváří náhodné hodnoty typu double a float.
\end{itemize}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{game_showcase.png}
        \caption{Ukázka běžící hry} 
    \end{figure}

\chapter{Použité programy a knihovny}
\section{CMake}
CMake je program, který generuje nativní soubory build systému pro různé platformy. Do textového
souboru \texttt{CMakeLists.txt} se zapisují zdrojové soubory, cesty ke knihovnám, které program
používá, a také konfigurace verze C++, kterou chce uživatel používat. CMake tyto informace předá
compileru, takže uživatel nemusí vypisovat pro každou kompilaci všechny dependencies svého programu.
Další výhodou je, že build vytvořený pomocí CMake může fungovat napříč platformami.
\cite{software_developement_with_cmake}

\section{GLAD}
GLAD je knihovna, která generuje loader na základě oficiální specifikace OpenGL. Od
verze OpenGL 1.1 nejsou moderní funkce přímo v systému, takže nejdou importovat do programu jako
knihovna, ale jsou implementovány v ovladačích grafických karet. Kvůli tomu by kompilátor nebyl
schopen najít deklarace těchto OpenGL funkcí. Proto se využívají loadery jako GLAD, které načtou tyto
funkce a skrze hlavičkový soubor je vloží do C++ programu.
\cite{opengl_loading_library}

\section{GLFW}
GLFW je knihovna určená pro vývoj aplikací využívajících OpenGL nebo Vulkan. Hlavním
účelem GLFW je otevírání, správa a nastavení vlastností oken. Pro každé okno je vytvořen kontext,
který obsahuje stav grafiky spojený s daným oknem. \gls{gpu} při vykreslování čerpá z kontextu
uchovaný stav, který funguje jako prostředník mezi programem a \gls{gpu}. Další důležitou funkcí je
zpracovávání vstupů uživatele, jako je stisk klávesy či myši, čímž je program schopen reagovat na
interakce uživatele s oknem.
\cite{glfw_introduction}

\section{GLM}
GLM je matematická knihovna určená pro grafický software. GLM poskytuje funkce a třídy implementované
se stejnými názvy a funkcemi jako \gls{glsl}, což usnadňuje práci se shadery. GLM se převážně používá
pro práci s maticemi a obsahuje funkce pro operace s nimi, což ulehčuje transformace objektů, jako je
posun či rotace. GLM také obsahuje generátor náhodných čísel nebo kvaterniony, které slouží k
provádění rotací ve 3D prostoru.
\cite{opengl_mathematics}

\section{stb\_image}
Knihovna stb\_image je jednoduchá knihovna pro načítání obrázků. Dokáže zpracovat většinu běžných
formátů obrázků, jako jsou PNG nebo JPG. Tyto obrázky ukládá jako syrová data do paměti. Pro každý
pixel jsou uložena 3 čísla při používání RGB nebo 4 čísla při RGBA.
\cite{image_loading}

\chapter{Herní mechaniky}
\section{Generátor čísel}
Pro mou hru jsem potřeboval nějaký generátor náhodných čísel pro počáteční x souřadnici ovoce nebo
pro rychlost, jakou bude padat. Moje classa využívá pseudonáhodný generátor mt19937. Tento
generátor po dodání seedu vygeneruje náhodnou sekvenci čísel. Pro vytvoření seedu používám funkci
random\_device, která vygeneruje náhodné číslo z náhodných parametrů systému. Generování čísel podle
parametrů systému je náhodnější, ale tento proces je poměrně pomalý, a proto se využívá jen na
generování seedu. Pro vytvoření čísla z nějakého rozmezí se používá funkce
uniform\_real\_distribution. Ta vydělí každé vygenerované číslo tím největším možným vygenerovaným
číslem, čímž vytvoří číslo v rozmezí od 0 do 1. Následně se rozmezí, které chceme vytvořit, přemapuje
na rozmezí od 0 do 1.
\cite{cppreference}

\section{Generování ovoce}
Pro generování a práci s ovocem jsem si vytvořil dvě pomocné struktury.
\begin{lstlisting}[caption={pomocne struktury}]
enum class FruitType
{
    apple = 0, coconut = 1
};

struct fruitAttributes
{
    FruitType type;
    glm::mat4 transform;
    float speed;
};
\end{lstlisting}
FruitType slouží k tomu, aby se přiřadila správná textura k danému ovoci a aby se při kolizi přidal
bod nebo odebral život. Ve fruitAttributes jsou všechny potřebné parametry pro každé ovoce pohromadě,
takže se s nimi lépe pracuje. Poté si vytvořím deque, do kterého si ukládám všechno ovoce, které je
na obrazovce. Při vytváření ovoce vygeneruji náhodnou rychlost a matici, ve které je náhodné posunutí
v souřadnici x. Pro mazání a kolize následně vždy jen iteruji skrz všechno ovoce a zjišťuji, zda se
dostalo pod hranu obrazovky nebo zda kolidovalo s košíkem.

\section{Vykreslování čísel}
Pro počítání skóre a životů jsem si vytvořil třídu pro vykreslování čísel. Protože čísla, která
potřebuji vykreslit, mohou mít libovolnou hodnotu, nevyplatí se pro každé číslo vytvářet samostatnou
texturu. Místo toho jsem využil techniku zvanou texture atlas. Tato technika využívá jednu velkou
texturu s číslicemi od 0 do 9. Každá cifra vykreslovaného čísla je samostatný objekt a je mu
přiřazena část textury s odpovídající číslicí. Aby byla číslice správně vycentrovaná, musí se každému
objektu přiřadit transformační matice. Pozice jednotlivé číslice závisí na celkové délce
vykreslovaného čísla a také na pozici dané cifry v čísle. V shaderu se pomocí posunu texturových
souřadnic určuje, jaká část textury se má vykreslit na daný objekt.

\section{Detekce kolize} Pro detekci kolizí jsem využil Axis\-Aligned Bounding Box (AABB) detekci.
Každý objekt je reprezentován dvojicí bodů (horní levý roh a dolní pravý roh), které určují obdélník
zarovnaný s osami. Kolize se zjišťuje porovnáním intervalů obou obdélníků na osách X a Y. Pokud dojde
u obou os k překryvu, objekty mezi sebou kolidují.

\begin{figure}[H]
        \includegraphics[width=\linewidth]{collisions_overlap.png}
        \caption{AABB collision detection \cite{real_time_rendering}}
\end{figure}

%%%%%%%%%%%%% ZÁVĚR
\chapter*{Závěr}
\addcontentsline{toc}{chapter}{Závěr}  % přidá do TOC
	
\nocite{*}
\printbibliography					% Vytvoří seznam literatury
\addcontentsline{toc}{chapter}{Bibliografie}
\printglossary[title={Zkratky}]		% Vytvoří seznam zkratek
\listoffigures						% Vytvoří seznam obrázků
\listoftables						% Vytvoří seznam tabulek

%%%%%%%%%%%%% PŘÍLOHY - APPENDIX 	
\begin{appendices}
	\chapter{Fotky z pokusů}	
	\lipsum[1]
    	%\pitem{Fotky z pokusů}
    	%\eitem{Vlastní program}
    	%\eitem{Dokumentace}
    	%\eitem{Testovací data}
	\chapter{Příloha další }
\end{appendices}
%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%% KONEC %%%%%%%%%%%%%%%%%%%%%%%%%
