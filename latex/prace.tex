%šablona pro maturitní práci Gymnázia Jírovcova 8, České Budějovice
% Autoři šablony: Jonáš Havelka, Michal Kočer, Daniel Sýkora
% Typ dokumentu: report
% veškeré úpravy v soubor MP.sty (styl maturitní práce)
\documentclass[12pt]{report}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{config}						  % Import stylu maturitní práce
\author{René Čakan}                  % AUTOR PRÁCE
\title{Programování grafické aplikace v C++}    % NÁZEV PRÁCE
\date{6. února 2026}                 % DATUM ODEVZDÁNÍ PRÁCE
\vedouci{Dr. rer. nat. Michal Kočer} % VEDOUCÍ PRÁCE
\place{V Českých Budějovicích}
\skolnirok{2025/2026}                  % ŠKOLNí ROK
\logo{\includegraphics[scale=1.25]{GJ8_logotyp}} %Logo školy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document} %%%%%%% začátek dokumentu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Titulní stránka + úvodní povinné stránky
\pagenumbering{roman}                   % číslování stránek římskými číslicemi
	\mytitlepage						% Vygenerování titulní strany
	
	\prohlaseni
    {
		Prohlašuji, že jsem tuto práci vypracoval samostatně s vyznačením všech použitých pramenů.
	}	
	
	\abstrakt
    {
       Tato práce se zaměřuje na základní vysvětlení počítačové grafiky. Zabývá se architekturou
       grafických karet a fungováním grafické zobrazovací pipeline. Dále popisuje fungování knihovny
       OpenGL a programovací jazyky C a C++, ve kterých se s ní často pracuje. V~praktické části jsem
       naprogramoval hru pomocí OpenGL v C++.
	}
    {
            počítačová grafika, grafická karta, grafická pipeline, OpenGL, C++
    }
	\podekovani
    {
        Rád bych poděkoval Dr. rer. nat. Michalu Kočerovi za rady a připomínky při vedení mé
        maturitní práce. Děkuji také své rodině a přátelům, kteří byli mojí emoční podporou.

	}
	
   {\tableofcontents\newpage}			% Obsah
	
\addtocounter{page}{1}		% Posunutí countru stránek
\pagenumbering{arabic}		% Číslování stránek arabskými číslicemi
\chapter*{Úvod}     % úvod práce 
    Počítačová grafika je poměrně rozsáhlá oblast informatiky, která má širokou škálu uplatnění, jako
    je vývoj videoher nebo aplikací s grafickým uživatelským rozhraním.
    Většina programátorů využívá pro vývoj vysoce abstraktní knihovny nebo herní enginy jako
    \textit{Pygame}, \textit{Unity} či \textit{Unreal Engine}. Vytváření výsledného produktu je díky
    tomu výrazně 
    jednodušší, avšak samotný proces vykreslování je skryt v kódu dané knihovny či herního enginu.
    I když jsou tyto knihovny a herní enginy vysoce optimalizované, nesprávné využívání funkcí
    kvůli neúplnému porozumění vnitřních procesů může vést k zhoršení výkonu aplikace.
    Cílem této práce je vysvětlení základních principů počítačové grafiky.

    První část práce vysvětluje fungování grafických karet a grafické zobrazovací pipeline.
    Dále popisuje fungování grafické knihovny OpenGL a představuje programovací
    jazyky C a C++, které jsou s touto knihovnou často používány. Druhá část popisuje fungování
    jednoduché hry napsané v C++, která využívá knihovnu OpenGL.
\addcontentsline{toc}{chapter}{Úvod}

%%%%%%%%%%%%%% TEORETICKÁ ČÁST %%%%%%%%%%%%%%%%%%	
\part{Teorie pro vývoj hry v OpenGL}  % název teoretické části (nenechávejte Teoretická část)
	
\chapter{Programovací jazyky}
			
\section{Programovací jazyk C}
    C je středněúrovňový programovací jazyk. Je svou podobou blízký strojovému kódu,
    ale už má prvky vyššího programovacího jazyka jako jsou funkce, datové struktury nebo to, že je
    strukturovaný. Je kompilovaný a statický, což znamená, že se program musí nejdříve přeložit do
    strojového kódu a až pak se může spustit. Datové typy jsou známy v čase kompilace, proto musí být
    všechny proměnné v kódu deklarovány, jelikož vkládání vstupních dat do programu probíhá až při
    běhu programu. Programuje se v něm strukturovaně a procedurálně, tedy kód se píše pomocí
    řídicích struktur (if, while, for atd.) a pomocí funkcí, které umožňují používat části
    kódu vícekrát. C nemá automatický správce paměti, takže je potřeba uvolňovat paměť manuálně. C
    má střídmou standardní knihovnu, která obsahuje základní matematické operace a funkce pro
    práci s pamětí a soubory, takže jakékoliv složitější datové struktury či funkce si člověk musí
    naprogramovat sám. Tato strohost a blízkost ke strojovému kódu z~C~dělá jeden z nejrychlejších
    programovacích jazyků.
    \cite{programming_in_c, the_c_programming_language, features_of_C,
    low-level_midlvel_and_high-level_language, structured_programming}

    C bylo vytvořeno Dennisem Ritchiem na počátku 70. let 20. století v AT\&T Bell Labs. 
    Jeho předchůdci byly jazyky ALGOL, CPL, BCPL a B. Jeho prvotním účelem bylo
    přepsat operační systém UNIX do použitelnějšího jazyka než Assembly a B. Už koncem 70. let bylo
    C populární, ale nebylo standardizované a vznikalo mnoho různých variant. Na začátku 80. let
    tedy American National Standards Institute (ANSI) zahájil práci na formální standardizované
    verzi. Tu dokončil v roce 1989 a je známa pod jménem C89. V průběhu let vycházely další verze,
    které jazyk zlepšovaly a modernizovaly. Nejdůležitější verze byly C99, C11 a C17. Norma C23 byla
    nedávno schválena a teď se implementuje do kompilátorů. V současnosti mezi nejpoužívanější
    kompilátory patří \textit{GCC}, \textit{Clang} a \textit{MSVC}. Jelikož bylo C velice populární,
    ovlivnilo řadu jiných programovacích jazyků, jako C++, C\#, Java, Rust, Go atd.
    \cite{the_c_book:_featuring_the_ansi_c_standart, c_a_reference_manual,
    programming_in_c, the_c_programming_language}

    C je univerzální programovací jazyk, má tedy širokou škálu využití. Jeho první využití bylo k
    napsání UNIXu, který později ovlivnil operační systémy jako Linux, macOS, iOS a Android.
    Používá se v programování softwaru s omezenou pamětí a výkonem, jako je firmware aut či v
    zařízeních chytrých domácností. Dále se využívá pro tvoření interpreterů a kompilátorů jako je
    \textit{GCC} nebo interpreter Pythonu. Také jsou v něm napsané systémové databáze \textit{MySQL} a 
    \textit{Oracle Database}.
    Kvůli jeho rychlosti jsou v něm napsané knihovny pro jiné programovací jazyky jako je
    \textit{NumPy}, OpenGL či \textit{GLFW}.
    \cite{the_c_book:_featuring_the_ansi_c_standart, programming_in_c,
    top_applications_of_c_programming}

    Zde je jednoduchý program, který načte ze vstupu počet čísel, která chce uživatel setřídit.
    Následně daná čísla načte a vytiskne je seřazená:

\begin{lstlisting}[caption={sort\_n\_numbers.c}]
#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}

int main(void)
{
    int sizeOfArray;
    scanf("%d", &sizeOfArray);
    int *array = malloc(sizeOfArray *sizeof(int));

    for(int i = 0; i < sizeOfArray; ++i)
        scanf("%d", &array[i]);

    qsort(array, sizeOfArray, sizeof(int), compare);

    for(int i = 0; i < sizeOfArray; ++i)
        printf("%d\n", array[i]);

    free(array);
    return 0;
}
\end{lstlisting}

\section{Programovací jazyk C++}
    Programovací jazyk C++ je v mnoha ohledech podobný jazyku C. Je stejně jako C středně\-úrovňový,
    kompilovaný, statický, má datové typy známé v době kompilace a nemá automatický správce
    paměti. V C++ se také programuje strukturovaně a procedurálně, ale na rozdíl od C,~také umožňuje
    programovat objektově. Objektové programování umožňuje používat objekty, které jsou instance
    tříd. Tyto třídy umožňují dědičnost, polymorfismus a zapouzdření, což
    dělá kód přehlednější a usnadňuje budoucí rozšiřování a debuggování. 
    Dalším rozdílem je standardní knihovna, kterou má C++ rozsáhlejší.
    Obsahuje nové kontejnery jako \texttt{vector}, \texttt{map} a \texttt{priority\_queue}, které jsou tvořeny pokročilejšími
    datovými strukturami jako binární vyhledávací strom nebo \texttt{heap}. Dále obsahuje nové algoritmy,
    například \texttt{sort}, \texttt{find} nebo \texttt{count}. Kvůli velké podobnosti C a C++ se
    často může C kód používat v~C++, ale není tomu tak vždy. Například tento kód:
\begin{lstlisting}[caption={incompatibility\_example.c}]
int class(int new, int bool); 
\end{lstlisting}
    V C tento kód vytvoří funkci \texttt{class}, která vrací int a má dva parametry \texttt{new} a
    \texttt{bool}. V C++ jsou ale
    class, new a bool klíčová slova, která nelze použít v názvu proměnných a funkcí. Pokud chce
    programátor napsat C kód, který lze používat v C++ programech,
    doporučuje se programovat v C tak, aby daný C kód byl podmnožinou C++.
    \cite{the_cpp_programming_language, programming_principles_and_practice_using_cpp}

    C++ bylo vytvořeno Bjarnem Stroustrupem v roce 1979 v AT\&T Bell Labs. Před 
    vytvořením C++ pracoval Stroustrup s programovacím jazykem Simula 67, který byl
    objektově orientovaný a sloužil primárně k vytváření simulací. Stroustrupovi přišlo
    objektově orientované programování
    velmi užitečné, ale Simula 67 byl příliš pomalý pro větší projekty. Rozhodl
    se vytvořit nadmnožinu jazyka C, která by umožňovala objektově orientované programování a zároveň
    si zachovala rychlost C, s názvem C with Classes. V roce 1982 byl Stroustrup se stavem C with
    Classes zklamán. Nepřišlo mu, že oproti C přináší významné zlepšení a~rozhodl se jazyk dále
    vylepšovat nad rámec objektově orientovaného programování. V roce 1983 byl jazyk přejmenován z
    C with Classes na C++. Dále bylo C++ v roce 1985 oficiálně 
    vydáno a začalo se používat komerčně. V roce 1998 byla
    vydána první standardizovaná verze s jménem C++98. Další významné verze, které jazyk
    modernizovaly a přidávaly mu nové funkce, byly C++03, C++11, C++14, C++17, C++20 a
    nejnovější verze C++23. C++ se kompiluje pomocí stejných kompilátorů jako C, tedy \textit{GCC},
    \textit{Clang} a \textit{MSVC}.
    \cite{programming_principles_and_practice_using_cpp, design_and_evolution_cpp, history_of_cpp, cpp_computer_language}

    C++ je stejně jako C univerzální programovací jazyk, a využívá se v široké škále odvětví. První
    využití je ve videoherním průmyslu. V C++ jsou napsané populární herní enginy jako \textit{Unity} nebo
    \textit{Unreal Engine}. Dále se v něm vytváří aplikace jako \textit{Photoshop} nebo \textit{Blender}. Využívá se v částech
    operačních systémů jako Apple macOS nebo Microsoft Windows OS. Dále se využívá při vytváření 
    internetových prohlížečů, například Firefox nebo Google Chrome. C++ se využívá i ve vědě,
    například v CERNu nebo v NASA. 
    \cite{the_cpp_programming_language, top_25_cpp_applications_in_real_world, what_is_cpp_used_for}

    Program se stejnou funkcí jako z kapitoli o C, ale napsán v C++
\begin{lstlisting}[caption={sort\_n\_numbers.cpp}]
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    int sizeOfArray;
    std::cin >> sizeOfArray;
    std::vector<int> arr(sizeOfArray);

    for(int i = 0; i < sizeOfArray; ++i)
        std::cin >> arr[i];

    std::sort(arr.begin(), arr.end());

    for(int i : arr)
        std::cout << i << '\n';

    return 0;
}
\end{lstlisting}


    
\clearpage
\chapter{Počitačová grafika}			
\section{Grafické karty}
\subsection{CPU vs. GPU}
    Tradičně běžela většina aplikací sekvenčně na procesorech s centrální výpočetní jednotkou
    (\gls{cpu}), která provádí instrukce 
    jednu po druhé. V průběhu 20. století se výkon \gls{cpu} významně zlepšoval až na
    bilion operací za sekundu, čímž se mohly zlepšovat grafické aplikace a využívat náročnější
    funkce. Na přelomu tisíceletí se ale vývoj začal zpomalovat, kvůli problému se spotřebou
    energie a odvodem tepla. Proto výrobci začali vytvářet \gls{cpu} s více jádry, ale ani to nebylo
    dostatečně výkonné na složité výpočty, a proto už v 70. a 80.
    letech začaly vznikat počítače, které nepracovaly sekvenčně, ale paralelně. V 90.
    letech se začaly vytvářet mikroprocesory, které se soustředily na paralelní výpočty (\gls{gpu}).
    V průběhu let se počet jader v \gls{gpu} dostal z jednotek na tisíce, což vytvořilo prostor pro
    inovaci v grafice a~tvorbě softwaru. 
    \cite{programming_massively_parallel_processors}

    Prvně bylo \gls{gpu} pouze v počítačích specializovaných pro 3D hry a vizualizace, ale postupně
    se stala součástí většiny počítačů. \gls{gpu} a \gls{cpu} se používají v~různých případech kvůli
    rozdílné architektuře. \gls{cpu} má jednotky až desítky jader a umí dělat jeden krok extrémně
    rychle kvůli sekvenčnímu zapojení.
    Velká část čipu je určena pro cache, tedy malou paměť, kam se ukládají data, která budou 
    pravděpodobně v budoucnosti potřeba. Díky tomu není třeba tak často komunikovat s pamětí s
    náhodným přístupem (\gls{ram}).
    Část čipu je také určena pro řídící jednotku, která umožňuje provádět instrukce ve vláknech
    paralelně nebo v~jiném sekvenčním pořadí, a přitom zachovat sekvenčnost celého procesu.
    \gls{cpu} má také menší propustnost paměti než \gls{gpu}, proto jsou programy s optimalizovaným
    přístupem do cache
    výrazně rychlejší. Na rozdíl od toho má \gls{gpu} stovky až tisíce jader.
    Jednotka řídící logiku a cache jsou v jádru menší a jednodušší, 
    takže reagují pomaleji na
    události. Po dokončení operací se většinou data vrací zpět do video \gls{ram} (\gls{vram}), což
    je díky velké propustnosti i pro velmi velký objem dat rychlé.
    \cite{programming_massively_parallel_processors}

    Do roku 2007 se \gls{gpu} používalo převážně pro vykreslování, ale v roce 2007 přišla NVIDIA s
    programovacím modelem pro paralelní výpočty \textit{CUDA}. Tento model umožňuje psát programy, které běží
    na \gls{gpu} a využívají \gls{cpu} na přenos dat a řízení těchto programů. Díky tomu mohly začít
    vznikat aplikace, které běží na \gls{cpu}, ale při potřebě náročnějších početních
    operací mohou běžet na \gls{gpu}, a tím zvýšit výkon. Pro účel vysvětlení programovacích modelů
    pro paralelní výpočty budu využívat model CUDA, přičemž existují i jiné podobné modely jako
    \textit{OpenCL} nebo \textit{SYCL}. 
    \cite{programming_massively_parallel_processors}

\subsection{Architektura a paměťová hierarchie GPU}
    \gls{gpu} s podporou CUDA je organizováno do pole paralelních streamovacích multiprocesorů
    (\gls{sm}). Každý \gls{sm} se skládá z několika streamovacích procesorů (\gls{sp}), které jsou
    základní výpočetní jednotkou, na nichž probíhají aritmetické operace. Další součástí jsou řídicí
    jednotky, které načítají instrukce pro konkrétní \gls{sm}. Řídicí jednotky také obsahují malou
    instrukční cache, aby se pro instrukce nemuselo často přistupovat k \gls{vram}, což by
    zpomalovalo výpočetní cykly. Dále je uvnitř \gls{sm}
    warp scheduler, který řídí, jaké skupiny vláken budou v~každém výpočetním cyklu použity.
    \cite{programming_massively_parallel_processors}

    Většina grafických karet má vlastní dynamickou \gls{ram} (\gls{dram}), ke které mají přístup
    všechny \gls{sm} a nazývá se globální paměť. V grafických kartách se nachází specifický typ
    \gls{dram} zvaný \gls{vram}. Tato paměť má
    jednotky až desítky gigabytů a dochází v ní k výměně dat mezi systémovou pamětí a \gls{vram}.
    Velká propustnost této paměti je zajištěna blokovým načítáním dat namísto po jednotlivých bytech.
    Samotná operace výměny dat mezi systémovou pamětí je ale poměrně náročná, a proto existuje
    hierarchie menších pamětí, jejichž cílem je minimalizovat počet přístupů do systémové paměti.
    Jedním z těchto typů je sdílená paměť, která má většinou desítky
    kilobajtů. Tuto paměť má každý \gls{sm} a každý \gls{sp} k ní může přistupovat. V každém \gls{sm}
    se také vyskytuje L1 cache, která slouží k uchovávání dat, ze kterých se nedávno četlo nebo byla
    změněna. Dále existuje L2 cache, která je větší než L1 cache a je jedna pro všechny \gls{sm}.
    Používá se pro uchovávání dat nedávno získaných nebo poslaných do \gls{vram}. Část \gls{vram} je
    také určena pro dva jiné typy paměti, a to texture a constant memory. Obě paměti mají k sobě
    přiřazenou svoji cache, která je pouze pro čtení. Díky tomu lze často používané hodnoty
    uchovávat v cache bez obavy z toho, že by se daná proměnná mohla v průběhu změnit. Nejmenší a
    nejrychlejší částí paměti jsou register files. Tato paměť přímo komunikuje s \gls{sp} a
    ukládají se do ní dočasné proměnné a mezivýpočty.
    \cite{programming_massively_parallel_processors, memory_hierarchy_of_gpu, memory_types_of_gpu}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{GPU_architecture.png}
        \caption{Typická architektura \gls{gpu} \cite{gpu_architecture_explained}} 
    \end{figure}

\subsection{Paralelismus}
    Paralelismus je výpočetní technika, která umožňuje vykonávání více operací najednou. Paralelismus
    se dá rozdělit do dvou kategorií. První z nich je úlohový paralelismus. Tento typ následuje
    Multiple Instructions, Multiple Data (MIMD) model. Tento model rozdělí různé úlohy mezi více
    vlákny nebo i jádry. Tento model se využívá, pokud na sobě nejsou úlohy závislé. Pokud by se
    například chtěla vypočítat suma pole s čísly, může každé vlákno počítat jednu polovinu a oba
    výsledky sečíst. MIMD se využívá v simulacích nebo ve webových aplikacích.
    \cite{programming_massively_parallel_processors, types_of_parallelism}

    Druhou metodou je datový paralelismus, který je definován Single Instruction, Multiple Data (SIMD)
    modelem. Tento model aplikuje jednu úlohu pro velké množství dat a využívá se v \gls{gpu}.
    Používá se při násobení matic, kde se daná matice dá rozdělit na menší části, nebo při
    vykreslování, kdy se jeden shader aplikuje pro každý pixel. V grafických kartách se jednotlivá
    vlákna sdružují do warpů, ty dále do bloků, které plánuje \gls{sm}. Do každého warpu jsou načteny
    stejné instrukce a postupně se mu dodávají data, na kterých dané instrukce provádí. Díky tomu lze
    i velké množství dat zpracovat velmi rychle, protože se dodávají s~velkou propustností a
    instrukce jsou na nich prováděny současně na velkém množství warpů.
    \cite{programming_massively_parallel_processors, types_of_parallelism}

\section{Grafická zobrazovací pipeline}
    Hlavní funkcí grafické zobrazovací pipeline je vykreslit dvourozměrný obraz z trojrozměrných
    objektů, pozice virtuální kamery, zdrojů světla atd., který je schopen být zobrazen například na
    monitoru. Pipeline se skládá z několika fází. Tyto fáze probíhají paralelně jak v rámci
    jednotlivých fází, tedy že jedna fáze probíhá pro větší množství dat najednou, tak i mezi
    jednotlivými fázemi.
    Po průchodu jednoho bloku dat jednou fází data přecházejí do další fáze, i když pro
    jiná data ještě předchozí fáze nemusí být ukončena. Hlavní čtyři fáze jsou aplikační fáze,
    geometrické zpracování, rasterizace a zpracování pixelů.
    \cite{real_time_rendering}

    Aplikační fáze je řízena samotnou aplikací a je většinou implementována jako software běžící na
    \gls{cpu}. Tato fáze nemá žádné podprvky, a proto může běžet paralelně na různých jádrech. V této
    části se zpracovávají vstupy od uživatele, které například pozměňují matici k posunutí, otočení
    nebo změně velikosti různých objektů. Také zde dochází k detekci kolizí, akceleračním
    algoritmům, fyzikálním simulacím a dalším výpočtům, které připravují data pro další scénu.
    \cite{real_time_rendering}

    Další částí pipeline je geometrické zpracování. Ta je zodpovědná za většinu operací pro každý
    trojúhelník a vrcholy, které tvoří objekty. Rozděluje se na čtyři podfáze: vertex shading,
    projekce, clipping a mapování na obrazovku. Vertex shading vypočítává pozici vrcholu a připravuje
    jeho data, jako barvy a textury. Objekt je transformován z modelového prostoru do světového
    prostoru, tedy souřadnic relevantních pro všechny objekty ve scéně. Dále se transformuje do
    kamerového prostoru, ve kterém je kamera v bodě nula. Následuje projekce,
    při které dochází k transformaci z
    kamerového prostoru do clip prostoru, aby bylo možné provést clipping. Clipping určuje, jaké
    objekty se budou vykreslovat. Pokud by například celý objekt byl mimo zorné pole scény, není
    vykreslován, aby zbytečně nezatěžoval \gls{gpu}. Poslední částí je mapování na obrazovku, které
    převede souřadnice z clip prostoru do souřadnic obrazovky připravených pro rasterizaci. Součástí
    vertex shadingu jsou také volitelné fáze vertex zpracování. Tessellation generuje vhodné
    trojúhelníky pro zakřivené povrchy, aby vypadaly realističtěji. Geometry shader umožňuje podle
    potřeby vytvářet nové vrcholy z existujících trojúhelníků nebo bodů. To se využívá například u
    malých částic, které se rozšíří na malé čtverce, aby byly lépe vidět na obrazovce.
    Poslední volitelná fáze je stream output, která umožňuje namísto poslání vrcholu do další fáze
    uložit vrcholy do bufferu, na kterých \gls{cpu} může dělat další výpočty či simulace.
    \cite{real_time_rendering}

    Následující fáze je rasterizace, jejímž účelem je nalézt všechny pixely uvnitř vykreslovaného
    trojúhelníku. Rasterizace se dělí na přípravu trojúhelníku a průchod trojúhelníkem. Při přípravě
    se vypočítávají diferenciály, rovnice hran a jiná podobná data, která jsou využívána ke
    zjišťování, zda daný pixel leží uvnitř trojúhelníku. Při průchodu se zjišťuje, zda střed pixelu
    leží uvnitř trojúhelníku, a pokud ano, vytvoří se pro daný pixel fragment. Vlastnosti jako barva,
    hloubka atd. jednotlivých fragmentů se získávají interpolací mezi vrcholy daného trojúhelníku a
    následně se ukládají do specifických bufferů. Výsledné fragmenty jsou následně předány do fáze
    pixelového zpracování.
    \cite{real_time_rendering}

    Pixelové zpracování se dělí na pixelové stínování a slučování. Ve fázi pixelového stínování se
    provádějí výpočty stínování jednotlivých pixelů ze stínovacích dat. Výsledkem je jeden nebo více
    barevných výstupů. V této fázi se používá hodně specifických technik, jako například texturování.
    Pixelové stínování je na rozdíl od ostatních fází, které jsou dány architekturou \gls{gpu}, dáno
    programovatelnými jádry \gls{gpu}. Při slučování dochází ke kombinaci výstupu pixelového
    stínování a uložených barev v bufferech. V této fázi se také řeší viditelnost, aby se vykresloval
    pro daný pixel fragment s nejmenší hloubkou.
    \cite{real_time_rendering}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{graphics_pipeline.png}
        \caption{Vizualizace grafické zobrazovací pipeline \gls{gpu} \cite{the_graphics_pipeline}} 
    \end{figure}

\section{Transformace}
    V průběhu vykreslování je často potřeba s objekty různě pohybovat. Mohli bychom pozměňovat
    souřadnice původních vrcholů a opětovně konfigurovat jejich buffery, ale to je výpočetně náročné.
    Místo toho se využívají transformace pomocí matic. Matice jsou obdélníková pole matematických
    výrazů. Souřadnice objektů se ukládají do 4D vektorů a transformace do 4x4 matic, které se mezi
    sebou vynásobí.
    \cite{learn_opengl}
    $$
    \begin{pmatrix}
    m_{00} \cdot x + m_{01} \cdot y + m_{02} \cdot z + m_{03} \cdot w \\
    m_{10} \cdot x + m_{11} \cdot y + m_{12} \cdot z + m_{13} \cdot w \\
    m_{20} \cdot x + m_{21} \cdot y + m_{22} \cdot z + m_{23} \cdot w \\
    m_{30} \cdot x + m_{31} \cdot y + m_{32} \cdot z + m_{33} \cdot w \\
    \end{pmatrix}
    =
    \begin{pmatrix}
    m_{00} & m_{01} & m_{02} & m_{03} \\
    m_{10} & m_{11} & m_{12} & m_{13} \\
    m_{20} & m_{21} & m_{22} & m_{23} \\
    m_{30} & m_{31} & m_{32} & m_{33}
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    w
    \end{pmatrix}
    $$
    Mezi základní operace patří translace, rotace a škálování. Translace je operace, při které se k
    původnímu vektoru přičte jiný vektor, čímž se původní objekt posune. Potřebujeme translační
    hodnoty násobit složkou w vektoru, která je nastavena na 1, aby neupravila tyto hodnoty. Proto
    používáme 4D vektor, protože s 3D vektorem by translace nebyla možná.
    $$
    \begin{pmatrix}
    x + T_{x} \\
    y + T_{y} \\
    z + T_{z} \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    1 & 0 & 0 & T_{x} \\
    0 & 1 & 0 & T_{y} \\
    0 & 0 & 1 & T_{z} \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    Další operací je škálování. Při této operaci se dané souřadnice násobí konstantou, čímž se může
    daný objekt zmenšit nebo zvětšit.
    $$
    \begin{pmatrix}
    S_{x} \cdot x \\
    S_{y} \cdot y \\
    S_{z} \cdot z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    S_{x} & 0 & 0 & 0 \\
    0 & S_{y} & 0 & 0 \\
    0 & 0 & S_{z} & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    Poslední důležitá operace je otáčení. Při této operaci se objekt otáčí podél jedné ze tří
    možných os.

    Rotace podle osy X:
    $$
    \begin{pmatrix}
    x \\
    \cos \theta \cdot y - \sin \theta \cdot z \\
    \sin \theta \cdot y + \cos \theta \cdot z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    1 & 0 & 0 & 0 \\
    0 & \cos \theta & -\sin \theta & 0 \\
    0 & \sin \theta & \cos \theta & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    
    Rotace podle osy Y:
    $$
    \begin{pmatrix}
    \cos \theta \cdot x + \sin \theta \cdot z \\
    y \\
    -\sin \theta \cdot x + \cos \theta \cdot z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    \cos \theta & 0 & \sin \theta & 0 \\
    0 & 1 & 0 & 0 \\
    -\sin \theta & 0 & \cos \theta & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    
    Rotace podle osy Z:
    $$
    \begin{pmatrix}
    \cos \theta \cdot x - \sin \theta \cdot y \\
    \sin \theta \cdot x + \cos \theta \cdot y \\
    z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    \cos \theta & -\sin \theta & 0 & 0 \\
    \sin \theta & \cos \theta & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$

    Při provádění transformací záleží na pořadí. Pokud je pro transformaci jednoho objektu více matic,
    pronásobí se matice mezi sebou a používá se výsledná matice. Při tvoření takové matice se ale
    postupuje v opačném pořadí násobení. Pokud bychom pro vektor $\mathbf{V}$ chtěli udělat operace
    a, b a c, tak to lze udělat následovně:

    $$ \mathbf{V'} = \mathbf{C} \cdot (\mathbf{B} \cdot (\mathbf{A} \cdot \mathbf{V})) $$
    nebo
    $$ \mathbf{M} = \mathbf{C} \cdot \mathbf{B} \cdot \mathbf{A} $$
    $$ \mathbf{V'} = \mathbf{M} \cdot \mathbf{V} $$

\chapter{OpenGL}
\section{Historie OpenGL}
OpenGL je považováno za aplikační programovací rozhraní (\gls{api}), které uživatelům poskytuje sadu
funkcí, které mohou používat k manipulaci s grafickou kartou. Specifikaci pro OpenGL tvoří
společnost Khronos Group, která určuje, jaké funkce existují a jak se budou chovat. Poté každá
společnost implementuje OpenGL API pro svůj druh grafických karet.
\cite{learn_opengl}

\section{OpenGL pipeline}
Grafická pipeline je velmi podobná obecné grafické pipeline popsané v předchozí
kapitole. Uživatel je schopen kontrolovat programovatelné fáze pipeline jako jsou shadery. 
Ostatní fáze jsou definovány \gls{api} a nelze je měnit.
\cite{learn_opengl}

\section{Shadery}
\subsection{Co to je shader}
Shader je malý program, který běží na \gls{gpu}. Tyto programy se spouštějí pro konkrétní část
grafické pipeline. Shadery přeměňují vstupy a převádějí je na výstupy potřebné pro následující fáze.
Starší verze OpenGL měly výchozí shadery, ale v novějších verzích je uživatel povinen vytvořit
základní shadery, aby \gls{gpu} mohlo něco vykreslit. Shadery jsou od sebe izolované a komunikují
spolu pouze pomocí vstupů a výstupů. Shaderů je více druhů a dva základní jsou vertex a fragment
shader.
\cite{learn_opengl}

\subsection{Vertex shader}
Základní účel vertex shaderu je zpracovávání vrcholů objektu. Do vertex shaderu vstupují atributy
vrcholů, jako barvy nebo 3D souřadnice bodů v modelovém prostoru. Vertex shader provádí transformace
těchto souřadnic do světového, kamerového a následně clip prostoru pomocí transformačních matic.
Vstupní data jsou uložena v \gls{gpu}, kde k nim má vertex shader přímý přístup.
\cite{learn_opengl}

\subsection{Fragment shader}
Účelem fragment shaderu je vypočítávání barevného výstupu pro pixely. Barvy se v OpenGL definují 4D
vektorem s floaty od 0.0 do 1.0. Tato čísla udávají sílu barev červená, zelená a~modrá (RGB).
Poslední číslo udává alfa hodnotu, tedy jak moc bude kombinace daných tří barev průhledná. Ve
fragment shaderu také dochází k texturování a různým efektům, jako jsou odlesky, stínování atd.
\cite{learn_opengl}

\subsection{Buffery a linkování}
Vstupní data vertex shaderu se ukládají do paměti \gls{gpu} pomocí Vertex Buffer
Objektu \gls{vbo}.
Ten v sobě dokáže uložit velké množství dat, díky čemuž jich posíláme více najednou a využíváme
vysokou propustnost \gls{gpu}. Tato data jsou pak jednoduše přístupná pro vertex shader, který s nimi
v \gls{gpu} pracuje. Následně se propojují vstupní data, což udává, jak jsou data propojena
k proměnným uvnitř vertex shaderu. Dalším důležitým objektem je Vertex Array Object \gls{vao}, do
kterého se ukládá, jak jsou data v VBO uspořádána a jak se mají propojit s vertex shadery.
\cite{learn_opengl}

Shadery se kompilují a linkují a následně ukládají do paměti \gls{gpu} jako součást shader programu.
To je objekt, který je výslednou verzí všech shaderů po linkování. Linkování shaderů propojuje výstupy
jednoho shaderu se vstupy druhého. Uživatel může mít více shader programů a pro každý objekt si
vybrat ten, který obsahuje požadované shadery.
\cite{learn_opengl}

\subsection{GLSL}
Shadery se píší v programovacím jazyce OpenGL Shading Language \gls{glsl}, který je podobný jazyku C.
\gls{glsl} je specificky navržen pro práci s grafikou a obsahuje užitečné funkce na manipulaci s
vektory a maticemi. Pokud jsou na sebe propojené dva shadery, výstupy z~prvního shaderu se přenesou do
druhého. Proměnné ovšem musí mít identický typ a velikost. Další důležitou funkcí jsou
uniformy, což jsou globální proměnné pro všechny shadery uvnitř jednoho shader programu. V uniformách
se často uchovávají matice a další konstanty.
\cite{learn_opengl}

Ukázka vertex a fragment shaderu naprogramovaného v \gls{glsl} z mojí hry:
\begin{lstlisting}[caption={vertex shader \texttt{fruit.vs}}]
#version 330
layout(location = 0) in vec3 pos;
layout(location = 1) in vec2 tex;

out vec2 TexCoords;
uniform mat4 transform;

void main()
{
    gl_Position = transform * vec4(pos, 1.0);
    TexCoords = tex;
}
\end{lstlisting}

\begin{lstlisting}[caption={fragment shader \texttt{fruit.fs}}]
#version 330 core
in vec2 TexCoords;
out vec4 FragColor;
uniform sampler2D myTexture;

void main()
{
    FragColor = texture(myTexture, TexCoords);
}
\end{lstlisting}

\section{Textury}
Textura je obrázek používaný k přidávání detailů k objektu. Pro každý vrchol objektu přiřadíme
souřadnici textury, která určuje, jaká část textury odpovídá danému vrcholu. Souřadnice textury se
ukládají do vstupních dat spolu s pozicemi vrcholů.
Textura se pak aplikuje ve fragment shaderu na každý fragment objektu,
čímž se promítne. Je také možno mít původní barvu objektu s jednou nebo více texturami na jednom
objektu. Následně se barvy a textury poměrově mixují podle nastavených alfa hodnot.
\cite{learn_opengl}

%%%%%%%%%%%%%% PRAKTICKÁ ČÁST %%%%%%%%%%%%%%%%%%	
\clearpage
\part{Vývoj hry v OpenGL} % název praktické části (nenechávejte název Praktická část)
\chapter{Architektura hry}
Pro vytváření své hry jsem si vybral OpenGL, protože je to nízkoúrovňového \gls{api}, jehož použití
vyžaduje základní porozumění grafické pipeline. Jako programovací jazyk jsem si vybral C++, protože
je s C knihovnami dobře kompatibilní, ale přitom mohu využívat prvky objektově orientovaného
programování, které jsou ve vývoji hry užitečné.

Moje hra má dva základní stavy. Prvním z nich je menu, ve kterém se uživatel nachází při prvním
zapnutí hry. Po kliknutí na tlačítko se uživatel přesouvá do druhého stavu běžící hry. Při
běhu hry je cílem hráče pohybovat košíkem a sbírat jablka, což zvyšuje skóre. Zároveň je cílem hráče
vyhýbat se padajícím kokosům, které hráči odebírají životy. Tento stav běží, dokud uživateli nedojdou
všechny životy, a následně je přesunut zpět do herního menu. Hra je tvořena větším počtem souborů,
které níže vysvětlím.

\begin{itemize}
    \item \texttt{main.cpp} -- Vytváří herní okno a spouští hlavní smyčku.
    \item \texttt{window.cpp} -- Inicializuje GLFW a spravuje okno aplikace.
    \item \texttt{game.cpp} -- Řídí přepínání herních stavů a resetuje proměnné při restartu hry.
    \item \texttt{game\_menu.cpp} -- Vykresluje stav menu a předává informaci, zda byla hra spuštěna.
    \item \texttt{game\_running.cpp} -- Vykresluje stav běžící hry a volá funkce pro objekty ve hře.
    \item \texttt{shader.cpp} -- Spravuje shadery, tedy kompilaci, linkování, aktivaci a nastavování
        uniforem.
    \item \texttt{rendering\_function.cpp} -- Poskytuje funkce pro načítání shaderů a propojování
        vstupních dat s \gls{vbo} a \gls{vao}.
    \item \texttt{texture.cpp} -- Spravuje vytváření, aktivaci a nastavení parametrů textur.
    \item \texttt{vertices.cpp} -- Uchovává vstupní data, jako jsou souřadnice objektů a textur.
    \item \texttt{fruit.cpp} -- Spravuje vytváření, pohyb a mazání ovoce. 
    \item \texttt{player.cpp} -- Spravuje pohyb hráče.
    \item \texttt{text.cpp} -- Spravuje vytváření a aktualizaci textu pro počítání životů a bodů.
    \item \texttt{collision\_detection.cpp} -- Zjišťuje, zda dochází ke kolizi hráče s ovocem, a
        případně volá aktualizaci životů a skóre.
    \item \texttt{random.cpp} -- Vytváří náhodná čísla typu double a float.
\end{itemize}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{game_showcase.png}
        \caption{Ukázka běžící hry} 
    \end{figure}

\chapter{Použité programy a knihovny}
\section{CMake}
CMake je program, který generuje nativní soubory sestavovacího systému pro různé platformy. Do
textového
souboru \texttt{CMakeLists.txt} se zapisují zdrojové soubory, cesty ke knihovnám, které program
používá, a také konfigurace verze C++, kterou chce uživatel používat. CMake tyto informace předá
kompilátoru, takže uživatel nemusí vypisovat pro každou kompilaci všechny závislosti svého programu.
Další výhodou je, že sestavení vytvořené pomocí CMake může fungovat napříč platformami.
\cite{software_developement_with_cmake}

\section{GLAD}
GLAD je knihovna, která generuje zavaděč na základě oficiální specifikace OpenGL. Od
verze OpenGL 1.1 nejsou moderní funkce přímo v systému, takže nejdou importovat do programu jako
knihovna, ale jsou implementovány v ovladačích grafických karet. Kvůli tomu by kompilátor nebyl
schopen najít deklarace těchto OpenGL funkcí. Proto se využívají zavaděče jako GLAD, které načtou tyto
funkce a skrze hlavičkový soubor je vloží do C++ programu.
\cite{opengl_loading_library}

\section{GLFW}
GLFW je knihovna určená pro vývoj aplikací využívajících OpenGL nebo Vulkan. Hlavním
účelem GLFW je otevírání, správa a nastavení vlastností oken. Pro každé okno je vytvořen kontext,
který obsahuje stav grafiky spojený s daným oknem. \gls{gpu} při vykreslování čerpá z kontextu
uchovaný stav, který funguje jako prostředník mezi programem a \gls{gpu}. Další důležitou funkcí je
zpracovávání vstupů uživatele, jako je stisk klávesy či myši, čímž je program schopen reagovat na
interakce uživatele s oknem.
\cite{glfw_introduction}

\section{GLM}
GLM je matematická knihovna určená pro grafický software. GLM poskytuje funkce a třídy implementované
se stejnými názvy a funkcemi jako \gls{glsl}, což usnadňuje práci se shadery. GLM se převážně používá
pro práci s maticemi a obsahuje funkce pro operace s nimi, což ulehčuje transformace objektů.
GLM také obsahuje generátor náhodných čísel nebo kvaterniony, které slouží k
provádění rotací ve 3D prostoru.
\cite{opengl_mathematics}

\section{stb\_image}
Knihovna \textit{stb\_image} je jednoduchá knihovna pro načítání obrázků. Dokáže zpracovat většinu běžných
formátů obrázků, jako jsou PNG nebo JPG. Tyto obrázky ukládá jako surová data do paměti. Pro každý
pixel jsou uložena 3 čísla při používání RGB nebo 4 čísla při RGBA.
\cite{image_loading}

\chapter{Herní mechaniky}
\section{Generátor čísel}
Pro mou hru jsem potřeboval nějaký generátor náhodných čísel pro počáteční x souřadnici ovoce nebo
pro rychlost, jakou bude padat. Moje třída využívá pseudonáhodný generátor mt19937. Tento
generátor po dodání seedu vygeneruje náhodnou sekvenci čísel. Pro vytvoření seedu používám funkci
random\_device, která vygeneruje náhodné číslo z náhodných parametrů systému. Generování čísel podle
parametrů systému je náhodnější, ale tento proces je poměrně pomalý, a proto se využívá jen na
generování seedu. Pro vytvoření čísla z nějakého rozmezí se používá funkce
uniform\_real\_distribution. Ta převádí náhodně vygenerované číslo z generátoru na reálné číslo z
požadovaného intervalu. Minimální hodnota generátoru odpovídá dolní hranici intervalu a maximální
hodnota odpovídá horní hranici. Vygenerované číslo se následně přemapuje z intervalu generátoru do
cílového intervalu.
\cite{cppreference}

\section{Generování ovoce}
Pro generování a práci s ovocem jsem si vytvořil dvě pomocné struktury.
\begin{lstlisting}[caption={pomocne struktury}]
enum class FruitType
{
    apple = 0, coconut = 1
};

struct fruitAttributes
{
    FruitType type;
    glm::mat4 transform;
    float speed;
};
\end{lstlisting}
\texttt{FruitType} slouží k tomu, aby se přiřadila správná textura k danému ovoci a aby se vedělo, jaký efekt
nastane při kolizi. Ve \texttt{fruitAttributes} jsou všechny potřebné parametry pro každé ovoce pohromadě,
takže se s nimi lépe pracuje. Poté si vytvořím deque, do kterého si ukládám všechno ovoce, které je
na obrazovce. Při vytváření ovoce vygeneruji náhodnou rychlost a matici, ve které je náhodná
hodnota posunutí
ve směru osy X. Pro mazání a kolize následně vždy jen iteruji skrz všechno ovoce a zjišťuji, zda se
dostalo pod hranu obrazovky nebo zda kolidovalo s košíkem.

\section{Vykreslování čísel}
Pro počítání skóre a životů jsem si vytvořil třídu pro vykreslování čísel. Protože čísla, která
potřebuji vykreslit, mohou mít libovolnou hodnotu, nevyplatí se pro každé číslo vytvářet samostatnou
texturu. Místo toho jsem využil techniku zvanou texture atlas. Tato technika využívá jednu velkou
texturu s číslicemi od 0 do 9. Každá cifra vykreslovaného čísla je samostatný objekt, kterému je
přiřazena část textury s odpovídající číslicí. Aby byla číslice správně vycentrovaná, musí se každému
objektu přiřadit transformační matice. Pozice jednotlivé číslice závisí na celkové délce
vykreslovaného čísla a také na pozici dané cifry v čísle. V shaderu se pomocí posunu texturových
souřadnic určuje, jaká část textury se má vykreslit na daný objekt.

\begin{figure}[H]
        \includegraphics[width=\linewidth]{text.png}
        \caption{Můj texture atlas pro vykreslování čísel}
\end{figure}

\section{Detekce kolize}
Pro detekci kolizí jsem využil Axis\-Aligned Bounding Box (AABB) detekci.
Každý objekt je reprezentován dvojicí bodů (horní levý roh a dolní pravý roh), které určují obdélník
zarovnaný s osami. Kolize se zjišťuje porovnáním intervalů obou obdélníků na osách X a Y. Pokud dojde
u obou os k překryvu, objekty mezi sebou kolidují.

\begin{figure}[H]
        \includegraphics[width=\linewidth]{collisions_overlap.png}
        \caption{AABB collision detection \cite{real_time_rendering}}
\end{figure}

%%%%%%%%%%%%% ZÁVĚR
\chapter*{Závěr}
Cílem první části práce bylo čtenáři přiblížit fungování grafických karet a grafické zobrazovací
pipeline. Dále byly popsány principy grafické knihovny OpenGL a programovacích jazyků C a C++.
Rozsah práce neumožňuje popsat fungování OpenGL tak dopodrobna, aby byl čtenář schopen
naprogramovat vlastní aplikaci. Pro hlubší porozumění dané knihovny lze využít knihu Learn
OpenGL.

V druhé části práce je popsána vytvořená hra v jazyce C++. Hra využívá teorii z předchozí části
a základní OpenGL funkce pro práci s shadery a texturami, převádění souřadnic skrz různé souřadnicové
systémy a práci s transformačními maticemi.

Vzhledem k složitosti jazyka C++ kód není plně optimalizovaný, avšak pro hru takto malého
rozsahu je výkon dostačující.

Hra by se dala rozšířit například přidáním více typů ovoce nebo zobrazováním hráči nejvýše
dosaženého skóre v menu, ale pro účely demonstrace popsané teorie je rozsáhlost dostačující.

\addcontentsline{toc}{chapter}{Závěr}  % přidá do TOC
	
\nocite{*}
\printbibliography					% Vytvoří seznam literatury
\addcontentsline{toc}{chapter}{Bibliografie}
\printglossary[title={Zkratky}]		% Vytvoří seznam zkratek
\listoffigures						% Vytvoří seznam obrázků

\chapter*{Zdrojový kód}
Všechen zdrojový kód použitý při tvorbě této práce je v přiloženém zip souboru.
%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%% KONEC %%%%%%%%%%%%%%%%%%%%%%%%%
