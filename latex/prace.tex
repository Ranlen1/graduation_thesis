%šablona pro maturitní práci Gymnázia Jírovcova 8, České Budějovice
% Autoři šablony: Jonáš Havelka, Michal Kočer, Daniel Sýkora
% Typ dokumentu: report
% veškeré úpravy v soubor MP.sty (styl maturitní práce)
\documentclass[12pt]{report}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{config}						  % Import stylu maturitní práce
\author{René Čakan}                  % AUTOR PRÁCE
\title{Programování grafické aplikace v C++}    % NÁZEV PRÁCE
\date{14. února 2025}                 % DATUM ODEVZDÁNÍ PRÁCE
\vedouci{Dr. rer. nat. Michal Kočer} % VEDOUCÍ PRÁCE
\place{V Českých Budějovicích}
\skolnirok{2025/2026}                  % ŠKOLNí ROK
\logo{\includegraphics[scale=1.25]{GJ8_logotyp}} %Logo školy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document} %%%%%%% začátek dokumentu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Titulní stránka + úvodní povinné stránky
\pagenumbering{roman}                   % číslování stránek římskými číslicemi
	\mytitlepage						% Vygenerování titulní strany
	
	\prohlaseni{
		Prohlašuji, že jsem tuto práci vypracoval samostatně s vyznačením všech použitých pramenů.
	}	
	
	\abstrakt{
	}{
	}
	
	\podekovani{
	}
	
   {\tableofcontents\newpage}			% Obsah
	
\addtocounter{page}{1}		% Posunutí countru stránek
\pagenumbering{arabic}		% Číslování stránek arabskými číslicemi
\chapter*{Úvod}     % úvod práce 
\addcontentsline{toc}{chapter}{Úvod}

%%%%%%%%%%%%%% TEORETICKÁ ČÁST %%%%%%%%%%%%%%%%%%	
\part{Teorie k vývoji hry v OpenGL}  % název teoretické části (nenechávejte Teoretická část)
	
\chapter{Programovací jazyky}
			
\section{Programovací jazyk C}

    C je středněúrovňový programovací jazyk, tedy jazyk, který je podobou blízko strojovému kódu,
    ale má už prvky vyššího programovacího jazyka jako jsou funkce, datové struktury nebo to že je
    strukturovaný. Je kompilovaný a statický, což znamená, že se program musí nejdříve přeložit do
    strojového kódu a až pak se může spustit. Datové typy jsou známy v čase kompilace, proto všechny
    proměnné musí být v kódu deklarovány, jelikož vkládání vstupních dat do programu probíhá až při
    běhu programu. Programuje se v něm strukturovaně a procedurálně, tedy kód se píše pomocí
    řídících struktur (if, while, for atd.) a pomocí funkcí, které umožňují používat části
    kódu vícekrát. C nemá automatický správce paměti, takže je potřeba uvolňovat paměť manuálně. C
    má střídmou standardní knihovnu, která obsahuje základní matematické operace a funkce pro
    práci s pamětí a soubory, takže jakékoliv složitější datové struktury či funkce si člověk musí
    naprogramovat sám. Tato strohost a blízkost ke strojovému kódu z C dělá jeden z nejrychlejších
    programovacích jazyků.
    \cite{programming_in_c, the_c_programming_language, features_of_C,
    low-level_midlvel_and_high-level_language, structured_programming}

    C bylo vytvořeno Dennisem Ritchiem na počátku 70. let 20. století v AT\&T Bell Labs 
    Jeho předchůdci byly jazyky ALGOL, CPL, BCPL a B. Jeho prvotním účelem bylo
    přepsat operační systém UNIX do použitelnějšího jazyka než Assembly a B. Už koncem 70. let bylo
    C populární, ale nebylo standardizované a vznikalo mnoho různých variant. Na začátku 80. let
    tedy American National Standards Institute (ANSI) zahájil práci na formální standardizované
    verzi. Tu dokončili v roce 1989 a je známa pod jménem C89. V průběhu let vycházely další verze,
    které jazyk zlepšovaly a modernizovali. Nejdůležitější verze byly C99, C11 a C17. Norma C23 byla
    nedávno schválena a teď se implementuje do kompilátorů. V součastnosti mezi nejpoužívanější
    kompilátory patří GCC, Clang a MSVC. Jelikož bylo C velice populární,
    ovlivnilo řadu jiných programovacích jazyků, jako C\+\+, C\#, Java, Rust, Go atd.
    \cite{the_c_book:_featuring_the_ansi_c_standart, c_a_reference_manual,
    programming_in_c, the_c_programming_language}

    C je univerzální programovací jazyk, má tedy širokou škálu využití. Jeho první využití bylo k
    napsání UNIXu, který později ovlivnil operační systémy jako Linux, macOS, iOS a Android.
    Používá se v programování softwaru s omezenou pamětí a výkonem, jako je firmware aut či v
    zařízeních chytrých domácností. Dále se využívá pro tvoření kompilátorů a interpreterů jako je
    GCC nebo interpreter Pythonu. Také jsou v něm napsané systémové databáze MySQL a Oracle
    Database. Kvůli jeho rychlosti jsou v něm napsané knihovny pro jiné programovací jazyky jako je
    NumPy, OpenGL či GLFW.
    \cite{the_c_book:_featuring_the_ansi_c_standart, programming_in_c,
    top_applications_of_c_programming}

    Jednoduchý program, který načte ze vstupu počet čísel, která chce uživatel setřídit. Následně
    daná čísla načte a vytiskne je seřazená:

\begin{lstlisting}[caption={sort\_n\_numbers.c}]
#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}

int main(void)
{
    int sizeOfArray;
    scanf("%d", &sizeOfArray);
    int *array = malloc(sizeOfArray *sizeof(int));

    for(int i = 0; i < sizeOfArray; ++i)
        scanf("%d", &array[i]);

    qsort(array, sizeOfArray, sizeof(int), compare);

    for(int i = 0; i < sizeOfArray; ++i)
        printf("%d\n", array[i]);

    free(array);
    return 0;
}
\end{lstlisting}

\section{Programovací jazyk C++}
    Programovací jazyk C++ je v mnoha ohledech podobný jazyku C. Je stejně jako C středně\-úrovňový,
    kompilovaný, statický, má datové typy známé v době kompilace a nemá automatický správce
    paměti. V C++ se také programuje strukturovaně a procedurálně, ale na rozdíl od C, také umožňuje
    programovat objektově. Objektové programování umožňuje používat objekty, které jsou instance
    tříd. Tyto třídy umožňují dědičnost, polymorfismus a zapouzdření, což
    dělá kód přehlednější a usnadňuje budoucí rozšiřování a debuggování. 
    Dalším rozdílem je standardní knihovna, kterou má C++ rozsáhlejší.
    Obsahuje nové kontejnery jako vector, map, a priority\_queue, které jsou tvořeny pokročilejšími
    datovými strukturami jako binární vyhledávací strom nebo heap. Dále obsahuje nové algoritmy,
    například sort, find nebo count. Kvůli velké podobnosti C a C++ se často může C kód používat v
    C++, ale není tomu tak vždy. Například tento kód:
\begin{lstlisting}[caption={incompatibility\_example.c}]
int class(int new, int bool); 
\end{lstlisting}
    V C tento kód vytvoří funkci class, která vrací int a má dva parametry new a bool. V C++ jsou ale
    class, new a bool klíčová slova, která nelze použít v názvu proměnných a funkcí. Pokud chce
    programátor napsat C kód, který se bude jednoduše v C++ programech,
    doporučuje se programovat v C tak, aby daný C kód byl podmnožinou C++.
    \cite{the_cpp_programming_language, programming_principles_and_practice_using_cpp}

    C++ bylo vytvořeno Bjarnem Stroustrupem v roce 1979 v AT\&T Bell Labs. Před 
    vytvořením C++ pracoval Stroustrup s programovacím jazykem Simula 67, který byl
    objektově orientovaný a sloužil primárně k vytváření simulací. Stroustupovi přišlo
    objektově orientované programování
    velmi užitečné, ale Simula 67 byl příliš pomalý pro větší projekty. Rozhodl
    se vytvořit nadmnožinu jazyka C, která by umožňovala objektově orientované programování a zároveň
    si zachoval rychlost C, s názvem C with Classes. V roce 1982 byl Stroustrup se stavem C with
    Classes zklamán. Nepřišlo mu, že oproti C přináší významné zlepšení a rozhodl se jazyk dále
    vylepšovat nad rámec objektově orientovaného programováni. V roce 1983 byl jazyk přejmenován z
    C with Classes na C++. Dále bylo C++ v roce 1985 oficiálně 
    vydáno a začalo se používat komerčně. V roce 1998 byla
    vydána první standardizovaná verze s jménem C++98. Další významné verze, které jazyk
    modernizovaly a přidávaly mu nové funkce, byly C++03, C++11, C++14, C++17, C++20 a
    nejnovější verze C++23. C++ se kompiluje pomocí stejných kompilátorů jako C, tedy GCC, Clang
    a MSVC.
    \cite{programming_principles_and_practice_using_cpp, design_and_evolution_cpp, history_of_cpp, cpp_computer_language}

    C++ je stejně jako C univerzální programovací jazyk, a využívá se v široké škále odvětví. První
    využití je ve videoherním průmyslu. V C++ jsou napsané populární hrací enginy jako Unity nebo
    Unreal Engine. Dále se v něm vytváří aplikace jako Photoshop nebo Blender. Využívá se v částech
    operačních systémů jako Apple macOS nebo Microsoft Windows OS. Dále se využívá při vytváření 
    internetových prohlížečů, například Firefox nebo Google Chrome. C++ se využívá i ve vědě,
    například v CERNu nebo v NASA. 
    \cite{the_cpp_programming_language, top_25_cpp_applications_in_real_world, what_is_cpp_used_for}

    Program se stejnou funkcí jako z kapitoli o C, ale napsán v C++
\begin{lstlisting}[caption={sort\_n\_numbers.cpp}]
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    int sizeOfArray;
    std::cin >> sizeOfArray;
    std::vector<int> arr(sizeOfArray);

    for(int i = 0; i < sizeOfArray; ++i)
        std::cin >> arr[i];

    std::sort(arr.begin(), arr.end());

    for(int i : arr)
        std::cout << i << '\n';

    return 0;
}
\end{lstlisting}


    
\clearpage
\chapter{Počitačová grafika}			

\section{Historie počítačové grafiky}
    Není úplně jasné, který počítač jako první využíval počítačovou grafiku, ale začnu počítačem
    Small-Scale Experimental Machine (\gls{ssem}). 
    Tento počítač byl vytvořen v roce 1948 na Manchesterské
    univerzitě a jeho tvůrci byli Frederic C. Williams, Tom Kilburn a Geoff Tootill. Tento počítač
    byl první počítač s uloženým programem, tedy počítač, který měl svůj program uložen ve stejné
    paměti jako data, se kterými počítač pracoval. Data uchovával na katodové trubici (\gls{crt}),
    které se později začalo říkat Williamsova trubice. Tato trubice si dokázala pamatovat až 2048
    bitů, které byly uchovávány jako elektrické náboje. Součástí trubice byl i displej, který na
    svém fosforovém povrchu promítal oblasti s nábojem. Takto vznikl první počítač s digitálním
    displejem.
    \cite{history_of_the_gpu_new_developments, the_manchester_ssem}

    Dalším zajímavým počítačem byl Whirlwind. Americký Office of Naval Research a U.S. Air Force
    chtěli vytvořit počítač, ve kterém by dokázal
    běžet letecký simulátor. Tak tedy v roce 1947 začal Jay Forrester pracovat v laboratořích MIT
    na projektu Whirlwind. Při práci vyvinul Forrester paměť s náhodným přístupem (\gls{ram}),
    tvořenou magnetickými jádrami, skrz které proudil koincidenční proud. Počítač byl dokončen
    v roce 1951. Využíval \gls{crt} na zobrazování výsledků podobně jako \gls{ssem} a
    dokázal na svém displeji řešit rovnice,
    později i simulovat karetní hru blackjack. Následně se projekt Whirlwind stal součástí projektu
    Semi-Automatic Ground Environment (SAGE). Ten měl za úkol vytvořit počítačový systém, který by
    pomocí radarů dokázal odhalovat letadla a řídit obranné síly proti případným letadlům. Projekt
    SAGE byl jeden z prvních systémů, které využívaly interaktivní ovládání pomocí klávesnice či
    speciálního světelného pera. Pokud bylo perem namířeno na ikonu letadla, zachytilo světlo
    z displeje a počítač zobrazil informace o daném letadle jako rychlost a směr jeho letu.
    Další počítač, který navazoval
    na projekt Whirlwind a SAGE, byl počítač TX-2, který byl vytvořen Wesem Clarkem na MIT. Ten byl
    na rozdíl od Whirlwindu tranzistorový. Zajímavým projektem, který tento počítač umožnil, byl
    Sketchpad vytvořen Ivanem Sutherlandem. Tento program byl první, který umožnil interaktivně
    kreslit na obrazovku. Obrazovka byla velká 7x7 palců s rastrem 1024x1024 bodů
    a psalo se na ní perem, které
    zachytávalo světlo z obrazovky. Poloha pera se poté poslala do počítače a na daném místě se
    vybarvil bod. Druhou rukou ovládal uživatel box s přibližně 40 tlačítky, které měly funkce jako
    mazaní, zoomování či ukládání. Tím vznikl první počítač s interaktivní počítačovou grafikou.
    \begin{figure}
        \includegraphics[width=\linewidth]{sketchpad.jpg}
        \caption{Skatchpad Ivana Sutherlanda \cite{vision_and_reality_of_hypertext_and_graphical_user_interfaces}}
    \end{figure}
    \cite{history_of_the_gpu_new_developments, milestones:whirldwind_computer, sage:semi-automatic_ground_environment_air_defense_system, a_critical_history_of_computer_graphics_and_animation, vision_and_reality_of_hypertext_and_graphical_user_interfaces}

    Společně s vývojem počítačové grafiky začaly vznikat i první videohry. Hra Spacewar! byla
    jedna z prvních, která se rozšířila po laboratoř9ch na amerických univerzitách. Hru 
    vytvořil na MIT Steve Russell a jeho přátelé v roce 1962. Hra byla vytvořena pro dva hráče,
    každý ovládal svou loď a jeho cílem bylo sestřelit loď protihráče. Lodě byly ovládány speciálním
    boxem, který se dá považovat za předchůdce moderních herních kontrolerů. Hra běžela na počítači
    PDP-1, který namísto rasterové grafiky využíval grafiku vektorovou.
    Věci vykreslené na osciloskopu byly definované matematickou funkcí.
    Díky tomu, že vektorová grafika nebyla tolik náročná na CPU
    jako rasterová, mohla ve hře být hvězda, která svojí gravitací působila na lodě.
    \cite{spacewar, vector_graphics, spacewar_controllers}

    S postupným vývojem počítačů se začaly vytvářet i grafické algoritmy. Jedním z nich je
    Bresenhamův algoritmus. Vytvořil ho Jack Elton Bresenham v roce 1962 v International
    Business Machines Corporation (IBM). Tento algoritmus se používá ke kreslení úsečky mezi dvěma
    body. Jelikož počítačová obrazovka je rozdělena na pixely, pokud daná úsečka není vodorovná ani
    svislá, nelze ji vykreslit přesně. Algoritmus determinuje, jaký z dvojice
    pixelů se více blíží funkci požadované úsečky a tento pixel vybarví. Dalším zajímavým algoritmem
    je ray casting. První obrázek byl vytvořen v roce 1968. Tento algoritmus funguje tak, že
    nejdříve uživatel definuje objekty, které chce mít ve své scéně jako matematické rovnice. Pro
    každý objekt se definuje model osvětlení, což udává jakou má barvu a jak
    se od něj světlo odráží. Poté se z pohledu kamery vyšle na každý pixel na obrazovce paprsek. Ten
    putuje, dokud se nezastaví o nějaký námi vytvořený objekt. Následně se z každého místa zastavení
    vyšle stínový paprsek do zdroje světla. Pokud cestou tento paprsek potká nějaký jiný objekt, daný
    objekt blokuje světlo, takže tento bod bude ve stínu.
    \cite{history_of_the_gpu_new_developments, bresenhams_line_algorithm_in_computer_graphics, ray_tracing}

    V průběhu 70. let se vyvíjely a vylepšovaly renderovací algoritmy. Jedním z problémů, který 
    bylo potřeba vyřešit, byl hidden surface determination problem. 
    Renderování částí objektů, které nejsou z pohledu
    kamery vidět zbytečně zatěžuje CPU. Tento problém řeší více rozdílných algoritmů, jako Z-buffer
    algorithm, Painter\'s algorithm nebo Binary Space Partitioning. Nejpopulárnější z nich je
    Z-buffer algoritmus vytvořen Wolfgangem Straßerem v roce 1974. Depth buffer uchovává 
    nejmenší dosud naleznutou hloubku a pokud se přidá nový fragment na daný pixel, algoritmus
    porovná obě hloubky a pokud je blíže kameře, depth buffer se přepíše na novou hloubku.
    Další významný pokrok byl v oblasti shadingu. Doposud se využíval k barvení flat shading,
    takže každý polygon měl svojí vlastní barvu. V roce 1971 vytvořil Henri Gouraud gouraud shading.
    Tato metoda ukládá barvu polygonů jen do vrcholu daného polygonu, a následně se vypočítává barva
    každého pixelu váženým poměrem podle vzdálenosti od daného vrcholu. Dalším z důležitých techink
    je Phong shading, kterou vytvořil Bui Tuong Phong v roce 1974. Por každý pixel se počítá, jak
    na daný pixel dopadá světlo a jak se od něj odráží. To se následně aplikuje pro výhcozí barvu
    polygonu. Tato technika je velice náročná a mohla se plně začít využívat až s rovojem GPU.
    Pokrok se udělal i v realističnosti povrchů. Pokud by povrch měl mýt nějaké výstupky čí hrbolky,
    museli by býti dodány v popisu daného polygonu. Tento problém řeší technika zvaná Bump Mapping,
    vytvořena Jamesem Blinnem v roce 1978. Vytvoří se texturová mapa, která určuje kde je vrcholek a
    kde prohlubeň. Poté se ve fázi počítaní světla místa s vrcholekm udělají světlejší a místa s
    prohlubní tmavější, což dodává efekt hrbolatého povrchu na uplně rovném polygonu.
    \cite{hidden_surface_determination, z_buffer_algorithm, mastering_gourad_shading, what_is_phong, bump_mapping}

\section{Historie a architektura grafických karet}

\section{Grafická pipeline}

\section{Transformace a lineární algebra}

\chapter{OpengGL}

\section{Historie OpenGL}

\section{OpenGL pipeline}

\section{Shadery}

\section{Textury}

\chapter{to do}
    historie compileru C
    \gls{crt}

%%%%%%%%%%%%%% PRAKTICKÁ ČÁST %%%%%%%%%%%%%%%%%%	
\clearpage
\part{Vývoj hry v OpenGL} % název praktické části (nenechávejte název Praktická část)

\chapter{Grafika a zvuk}

\section{Aseprite}

\section{Bosca Ceoil}

\chapter{Použité knihovny}

\section{GLAD}

\section{GLFW}

\section{stb\_image}

\chapter{Herní scény}

\section{Scéna hlavního menu}

\section{Scéna pozastavené hry}

\section{Scéna hry}

\chapter{Serní mechaniky}

\section{Generování objektů}

\section{Pohyb hráče}

\section{Detekce kolize}

%%%%%%%%%%%%% ZÁVĚR
\chapter*{Závěr}
\addcontentsline{toc}{chapter}{Závěr}  % přidá do TOC
	
\nocite{*}
\printbibliography					% Vytvoří seznam literatury
\addcontentsline{toc}{chapter}{Bibliografie}
\printglossary[title={Zkratky}]		% Vytvoří seznam zkratek
\listoffigures						% Vytvoří seznam obrázků
\listoftables						% Vytvoří seznam tabulek

%%%%%%%%%%%%% PŘÍLOHY - APPENDIX 	
\begin{appendices}
	\chapter{Fotky z pokusů}	
	\lipsum[1]
    	%\pitem{Fotky z pokusů}
    	%\eitem{Vlastní program}
    	%\eitem{Dokumentace}
    	%\eitem{Testovací data}
	\chapter{Příloha další }
\end{appendices}
%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%% KONEC %%%%%%%%%%%%%%%%%%%%%%%%%
