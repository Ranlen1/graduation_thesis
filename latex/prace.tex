%šablona pro maturitní práci Gymnázia Jírovcova 8, České Budějovice
% Autoři šablony: Jonáš Havelka, Michal Kočer, Daniel Sýkora
% Typ dokumentu: report
% veškeré úpravy v soubor MP.sty (styl maturitní práce)
\documentclass[12pt]{report}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{config}						  % Import stylu maturitní práce
\author{René Čakan}                  % AUTOR PRÁCE
\title{Programování grafické aplikace v C++}    % NÁZEV PRÁCE
\date{6. února 2026}                 % DATUM ODEVZDÁNÍ PRÁCE
\vedouci{Dr. rer. nat. Michal Kočer} % VEDOUCÍ PRÁCE
\place{V Českých Budějovicích}
\skolnirok{2025/2026}                  % ŠKOLNí ROK
\logo{\includegraphics[scale=1.25]{GJ8_logotyp}} %Logo školy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document} %%%%%%% začátek dokumentu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Titulní stránka + úvodní povinné stránky
\pagenumbering{roman}                   % číslování stránek římskými číslicemi
	\mytitlepage						% Vygenerování titulní strany
	
	\prohlaseni{
		Prohlašuji, že jsem tuto práci vypracoval samostatně s vyznačením všech použitých pramenů.
	}	
	
	\abstrakt{
	}{
	}
	
	\podekovani{
	}
	
   {\tableofcontents\newpage}			% Obsah
	
\addtocounter{page}{1}		% Posunutí countru stránek
\pagenumbering{arabic}		% Číslování stránek arabskými číslicemi
\chapter*{Úvod}     % úvod práce 
\addcontentsline{toc}{chapter}{Úvod}

%%%%%%%%%%%%%% TEORETICKÁ ČÁST %%%%%%%%%%%%%%%%%%	
\part{Teorie k vývoji hry v OpenGL}  % název teoretické části (nenechávejte Teoretická část)
	
\chapter{Programovací jazyky}
			
\section{Programovací jazyk C}
    C je středněúrovňový programovací jazyk, tedy jazyk, který je podobou blízko strojovému kódu,
    ale má už prvky vyššího programovacího jazyka jako jsou funkce, datové struktury nebo to že je
    strukturovaný. Je kompilovaný a statický, což znamená, že se program musí nejdříve přeložit do
    strojového kódu a až pak se může spustit. Datové typy jsou známy v čase kompilace, proto všechny
    proměnné musí být v kódu deklarovány, jelikož vkládání vstupních dat do programu probíhá až při
    běhu programu. Programuje se v něm strukturovaně a procedurálně, tedy kód se píše pomocí
    řídících struktur (if, while, for atd.) a pomocí funkcí, které umožňují používat části
    kódu vícekrát. C nemá automatický správce paměti, takže je potřeba uvolňovat paměť manuálně. C
    má střídmou standardní knihovnu, která obsahuje základní matematické operace a funkce pro
    práci s pamětí a soubory, takže jakékoliv složitější datové struktury či funkce si člověk musí
    naprogramovat sám. Tato strohost a blízkost ke strojovému kódu z C dělá jeden z nejrychlejších
    programovacích jazyků.
    \cite{programming_in_c, the_c_programming_language, features_of_C,
    low-level_midlvel_and_high-level_language, structured_programming}

    C bylo vytvořeno Dennisem Ritchiem na počátku 70. let 20. století v AT\&T Bell Labs 
    Jeho předchůdci byly jazyky ALGOL, CPL, BCPL a B. Jeho prvotním účelem bylo
    přepsat operační systém UNIX do použitelnějšího jazyka než Assembly a B. Už koncem 70. let bylo
    C populární, ale nebylo standardizované a vznikalo mnoho různých variant. Na začátku 80. let
    tedy American National Standards Institute (ANSI) zahájil práci na formální standardizované
    verzi. Tu dokončili v roce 1989 a je známa pod jménem C89. V průběhu let vycházely další verze,
    které jazyk zlepšovaly a modernizovali. Nejdůležitější verze byly C99, C11 a C17. Norma C23 byla
    nedávno schválena a teď se implementuje do kompilátorů. V součastnosti mezi nejpoužívanější
    kompilátory patří GCC, Clang a MSVC. Jelikož bylo C velice populární,
    ovlivnilo řadu jiných programovacích jazyků, jako C\+\+, C\#, Java, Rust, Go atd.
    \cite{the_c_book:_featuring_the_ansi_c_standart, c_a_reference_manual,
    programming_in_c, the_c_programming_language}

    C je univerzální programovací jazyk, má tedy širokou škálu využití. Jeho první využití bylo k
    napsání UNIXu, který později ovlivnil operační systémy jako Linux, macOS, iOS a Android.
    Používá se v programování softwaru s omezenou pamětí a výkonem, jako je firmware aut či v
    zařízeních chytrých domácností. Dále se využívá pro tvoření kompilátorů a interpreterů jako je
    GCC nebo interpreter Pythonu. Také jsou v něm napsané systémové databáze MySQL a Oracle
    Database. Kvůli jeho rychlosti jsou v něm napsané knihovny pro jiné programovací jazyky jako je
    NumPy, OpenGL či GLFW.
    \cite{the_c_book:_featuring_the_ansi_c_standart, programming_in_c,
    top_applications_of_c_programming}

    Jednoduchý program, který načte ze vstupu počet čísel, která chce uživatel setřídit. Následně
    daná čísla načte a vytiskne je seřazená:

\begin{lstlisting}[caption={sort\_n\_numbers.c}]
#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}

int main(void)
{
    int sizeOfArray;
    scanf("%d", &sizeOfArray);
    int *array = malloc(sizeOfArray *sizeof(int));

    for(int i = 0; i < sizeOfArray; ++i)
        scanf("%d", &array[i]);

    qsort(array, sizeOfArray, sizeof(int), compare);

    for(int i = 0; i < sizeOfArray; ++i)
        printf("%d\n", array[i]);

    free(array);
    return 0;
}
\end{lstlisting}

\section{Programovací jazyk C++}
    Programovací jazyk C++ je v mnoha ohledech podobný jazyku C. Je stejně jako C středně\-úrovňový,
    kompilovaný, statický, má datové typy známé v době kompilace a nemá automatický správce
    paměti. V C++ se také programuje strukturovaně a procedurálně, ale na rozdíl od C, také umožňuje
    programovat objektově. Objektové programování umožňuje používat objekty, které jsou instance
    tříd. Tyto třídy umožňují dědičnost, polymorfismus a zapouzdření, což
    dělá kód přehlednější a usnadňuje budoucí rozšiřování a debuggování. 
    Dalším rozdílem je standardní knihovna, kterou má C++ rozsáhlejší.
    Obsahuje nové kontejnery jako vector, map, a priority\_queue, které jsou tvořeny pokročilejšími
    datovými strukturami jako binární vyhledávací strom nebo heap. Dále obsahuje nové algoritmy,
    například sort, find nebo count. Kvůli velké podobnosti C a C++ se často může C kód používat v
    C++, ale není tomu tak vždy. Například tento kód:
\begin{lstlisting}[caption={incompatibility\_example.c}]
int class(int new, int bool); 
\end{lstlisting}
    V C tento kód vytvoří funkci class, která vrací int a má dva parametry new a bool. V C++ jsou ale
    class, new a bool klíčová slova, která nelze použít v názvu proměnných a funkcí. Pokud chce
    programátor napsat C kód, který se bude jednoduše v C++ programech,
    doporučuje se programovat v C tak, aby daný C kód byl podmnožinou C++.
    \cite{the_cpp_programming_language, programming_principles_and_practice_using_cpp}

    C++ bylo vytvořeno Bjarnem Stroustrupem v roce 1979 v AT\&T Bell Labs. Před 
    vytvořením C++ pracoval Stroustrup s programovacím jazykem Simula 67, který byl
    objektově orientovaný a sloužil primárně k vytváření simulací. Stroustupovi přišlo
    objektově orientované programování
    velmi užitečné, ale Simula 67 byl příliš pomalý pro větší projekty. Rozhodl
    se vytvořit nadmnožinu jazyka C, která by umožňovala objektově orientované programování a zároveň
    si zachoval rychlost C, s názvem C with Classes. V roce 1982 byl Stroustrup se stavem C with
    Classes zklamán. Nepřišlo mu, že oproti C přináší významné zlepšení a rozhodl se jazyk dále
    vylepšovat nad rámec objektově orientovaného programováni. V roce 1983 byl jazyk přejmenován z
    C with Classes na C++. Dále bylo C++ v roce 1985 oficiálně 
    vydáno a začalo se používat komerčně. V roce 1998 byla
    vydána první standardizovaná verze s jménem C++98. Další významné verze, které jazyk
    modernizovaly a přidávaly mu nové funkce, byly C++03, C++11, C++14, C++17, C++20 a
    nejnovější verze C++23. C++ se kompiluje pomocí stejných kompilátorů jako C, tedy GCC, Clang
    a MSVC.
    \cite{programming_principles_and_practice_using_cpp, design_and_evolution_cpp, history_of_cpp, cpp_computer_language}

    C++ je stejně jako C univerzální programovací jazyk, a využívá se v široké škále odvětví. První
    využití je ve videoherním průmyslu. V C++ jsou napsané populární hrací enginy jako Unity nebo
    Unreal Engine. Dále se v něm vytváří aplikace jako Photoshop nebo Blender. Využívá se v částech
    operačních systémů jako Apple macOS nebo Microsoft Windows OS. Dále se využívá při vytváření 
    internetových prohlížečů, například Firefox nebo Google Chrome. C++ se využívá i ve vědě,
    například v CERNu nebo v NASA. 
    \cite{the_cpp_programming_language, top_25_cpp_applications_in_real_world, what_is_cpp_used_for}

    Program se stejnou funkcí jako z kapitoli o C, ale napsán v C++
\begin{lstlisting}[caption={sort\_n\_numbers.cpp}]
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    int sizeOfArray;
    std::cin >> sizeOfArray;
    std::vector<int> arr(sizeOfArray);

    for(int i = 0; i < sizeOfArray; ++i)
        std::cin >> arr[i];

    std::sort(arr.begin(), arr.end());

    for(int i : arr)
        std::cout << i << '\n';

    return 0;
}
\end{lstlisting}


    
\clearpage
\chapter{Počitačová grafika}			
\section{Historie počítačové grafiky (tuto sekci mozna uplne smazu, proto neni dodelana)}
    Není úplně jasné, který počítač jako první využíval počítačovou grafiku, ale začnu počítačem
    Small-Scale Experimental Machine (\gls{ssem}). 
    Tento počítač byl vytvořen v roce 1948 na Manchesterské
    univerzitě a jeho tvůrci byli Frederic C. Williams, Tom Kilburn a Geoff Tootill. Tento počítač
    byl první počítač s uloženým programem, tedy počítač, který měl svůj program uložen ve stejné
    paměti jako data, se kterými počítač pracoval. Data uchovával na katodové trubici (\gls{crt}),
    které se později začalo říkat Williamsova trubice. Tato trubice si dokázala pamatovat až 2048
    bitů, které byly uchovávány jako elektrické náboje. Součástí trubice byl i displej, který na
    svém fosforovém povrchu promítal oblasti s nábojem. Takto vznikl první počítač s digitálním
    displejem.
    \cite{history_of_the_gpu_new_developments, the_manchester_ssem}

    Dalším zajímavým počítačem byl Whirlwind. Americký Office of Naval Research a U.S. Air Force
    chtěli vytvořit počítač, ve kterém by dokázal
    běžet letecký simulátor. Tak tedy v roce 1947 začal Jay Forrester pracovat v laboratořích MIT
    na projektu Whirlwind. Při práci vyvinul Forrester paměť s náhodným přístupem (\gls{ram}),
    tvořenou magnetickými jádrami, skrz které proudil koincidenční proud. Počítač byl dokončen
    v roce 1951. Využíval \gls{crt} na zobrazování výsledků podobně jako \gls{ssem} a
    dokázal na svém displeji řešit rovnice,
    později i simulovat karetní hru blackjack. Následně se projekt Whirlwind stal součástí projektu
    Semi-Automatic Ground Environment (SAGE). Ten měl za úkol vytvořit počítačový systém, který by
    pomocí radarů dokázal odhalovat letadla a řídit obranné síly proti případným letadlům. Projekt
    SAGE byl jeden z prvních systémů, které využívaly interaktivní ovládání pomocí klávesnice či
    speciálního světelného pera. Pokud bylo perem namířeno na ikonu letadla, zachytilo světlo
    z displeje a počítač zobrazil informace o daném letadle jako rychlost a směr jeho letu.
    Další počítač, který navazoval
    na projekt Whirlwind a SAGE, byl počítač TX-2, který byl vytvořen Wesem Clarkem na MIT. Ten byl
    na rozdíl od Whirlwindu tranzistorový. Zajímavým projektem, který tento počítač umožnil, byl
    Sketchpad vytvořen Ivanem Sutherlandem. Tento program byl první, který umožnil interaktivně
    kreslit na obrazovku. Obrazovka byla velká 7x7 palců s rastrem 1024x1024 bodů
    a psalo se na ní perem, které
    zachytávalo světlo z obrazovky. Poloha pera se poté poslala do počítače a na daném místě se
    vybarvil bod. Druhou rukou ovládal uživatel box s přibližně 40 tlačítky, které měly funkce jako
    mazaní, zoomování či ukládání. Tím vznikl první počítač s interaktivní počítačovou grafikou.
    \cite{history_of_the_gpu_new_developments, milestones:whirldwind_computer, sage:semi-automatic_ground_environment_air_defense_system, a_critical_history_of_computer_graphics_and_animation, vision_and_reality_of_hypertext_and_graphical_user_interfaces}


    S postupným vývojem počítačů se začaly vytvářet i grafické algoritmy. Jedním z nich je
    Bresenhamův algoritmus. Vytvořil ho Jack Elton Bresenham v roce 1962 v International
    Business Machines Corporation (IBM). Tento algoritmus se používá ke kreslení úsečky mezi dvěma
    body. Jelikož počítačová obrazovka je rozdělena na pixely, pokud daná úsečka není vodorovná ani
    svislá, nelze ji vykreslit přesně. Algoritmus determinuje, jaký z dvojice
    pixelů se více blíží funkci požadované úsečky a tento pixel vybarví. Dalším zajímavým algoritmem
    je ray casting. První obrázek byl vytvořen v roce 1968. Tento algoritmus funguje tak, že
    nejdříve uživatel definuje objekty, které chce mít ve své scéně jako matematické rovnice. Pro
    každý objekt se definuje model osvětlení, což udává jakou má barvu a jak
    se od něj světlo odráží. Poté se z pohledu kamery vyšle na každý pixel na obrazovce paprsek. Ten
    putuje, dokud se nezastaví o nějaký námi vytvořený objekt. Následně se z každého místa zastavení
    vyšle stínový paprsek do zdroje světla. Pokud cestou tento paprsek potká nějaký jiný objekt, daný
    objekt blokuje světlo, takže tento bod bude ve stínu.
    \cite{history_of_the_gpu_new_developments, bresenhams_line_algorithm_in_computer_graphics, ray_tracing}

    V průběhu 70. let se vyvíjely a vylepšovaly renderovací algoritmy. Jedním z problémů, který 
    bylo potřeba vyřešit, byl hidden surface determination problem. 
    Renderování částí objektů, které nejsou z pohledu
    kamery vidět zbytečně zatěžuje \gls{cpu}.
    Tento problém řeší více rozdílných algoritmů, jako Z-buffer
    algorithm, Painter\'s algorithm nebo Binary Space Partitioning. Nejpopulárnější z nich je
    Z-buffer algoritmus vytvořen Wolfgangem Straßerem v roce 1974. Depth buffer uchovává 
    nejmenší dosud naleznutou hloubku a pokud se přidá nový fragment na daný pixel, algoritmus
    porovná obě hloubky a pokud je blíže kameře, depth buffer se přepíše na novou hloubku.
    Další významný pokrok byl v oblasti shadingu. Doposud se využíval k barvení flat shading,
    takže každý polygon měl svojí vlastní barvu. V roce 1971 vytvořil Henri Gouraud gouraud shading.
    Tato metoda ukládá barvu polygonů jen do vrcholu daného polygonu, a následně se vypočítává barva
    každého pixelu váženým poměrem podle vzdálenosti od daného vrcholu. Dalším z důležitých techink
    je Phong shading, kterou vytvořil Bui Tuong Phong v roce 1974. Por každý pixel se počítá, jak
    na daný pixel dopadá světlo a jak se od něj odráží. To se následně aplikuje pro výhcozí barvu
    polygonu. Tato technika je velice náročná a mohla se plně začít využívat až s rovojem \gls{gpu}.
    Pokrok se udělal i v realističnosti povrchů. Pokud by povrch měl mýt nějaké výstupky čí hrbolky,
    museli by býti dodány v popisu daného polygonu. Tento problém řeší technika zvaná Bump Mapping,
    vytvořena Jamesem Blinnem v roce 1978. Vytvoří se texturová mapa, která určuje kde je vrcholek a
    kde prohlubeň. Poté se ve fázi počítaní světla místa s vrcholekm udělají světlejší a místa s
    prohlubní tmavější, což dodává efekt hrbolatého povrchu na uplně rovném polygonu.
    \cite{hidden_surface_determination, z_buffer_algorithm, mastering_gourad_shading, what_is_phong, bump_mapping}

    V 80. letech za začaly vytvářet první počítače, které byly dostupné pro veřejnost a začala
    se využívat \gls{gpu} . Počítačová
    grafika se začala využívat ve filmovém průmyslu. V roce 1982 vyšel film Tron, který první
    masivně využíval CGI. Posun se udělal i v modelování vytvořením matematického modelu
    Non-Uniform Rational B-Spline (NURBS). Tento model je schope z bodů a uzlu vytvořit 3D křivku
    nebo plochu. Další důležitý model byl Cook-Torrancův, který popisuje bidirectional reflective
    distribution function (BRDF). Tento model je podobný Phong shadingu, ale narozdíl od něj
    dodržuje fyzikální korektnost. Odražené světlo nikdy nemůže přesahovat světlo dopadající, címž
    se vyrendrovaná věc zdá realističtější. Dalším důležitým algoritmem je radiosity algororithm.
    Tento lgoritmus počítá světlo polygonu součtem světla kolik vyzařuje a kolik světla příjmá od
    ostatních polygonů. Narodíl ale od starších algoritmu všechny polygony také nějaké světlo
    odrážejí, což je dáno povrchem polygonu. Toto odražené světlo se také počítá do celkového
    osvícení ostatních polygonů. Významné zlepšení proběhlo u Ray Casting algoritmu. Paprsek se místo
    toho, aby se o polygon zastavil, odrazí a algoritmus se znovu rekurzivně spustí pro tento
    paprsek. Toto zlepšení umožňuje vidět v odraze jednoho polygonu polygon druhý.
    \cite{real_time_rendering, putting_the_original_trons_special_effects_together, what_are_nurbs, theory_brdf, radiosity_algorithm}

    V průběhu 90. let se významě vylepšovaly domácí počítače, které dokázali spustit i složitější
    programy a hry. 3D grafika se stala populárnější a vznikal pro ni i software jako Blender nebo
    3D Studio. Nevznikli žádné nové revoluční renderovací metody, ale díky zlepšení výkonu
    počítačů se mohly začít využívat metody dříve vytvořené, které byly příliě náročné pro
    tehdejší počítače. Velký pokrok zaznamenal filmový průmysl. Terminátor 2 použil CGI na
    realistického humanoidního robota. V roce 1995 vydal Pixar první celovečerní plně počítačově
    animovaný film toy strory. 90. léta jsou označována jako zlatý věk videoher. První z důležitých
    her je Wolfenstein 3D. Tato hra využívá ray-casting, takže není 3D, ale vytváří iluzi 3D
    prostoru. Další důležitou hrou je Doom. Tato hra byla 2.5D, tedy kombinovala prvky 2D a 3D. Zdi
    a podlaha byly 3D modely, ale příšery byly 2D sprity, kterych bylo vice a ukazovaly se podle toho
    pod jakým úhlem se hráč na příšeru koukal. První plně 3D hra bula Quake. Quake měl pokročilý
    client-server multiplayer, takže bylo možno hrát ne jen na LAN, ale i přes internet. 3D modely
    umožnili vývojářům přidat do hry 3. rozměr a tím i více patrové mapy či létející projektyly a
    nepřátele.
    \cite{a_timeline_of_3d_softwares, development_history, what_was_the_deal_with_doom, how_quake_multiplayer_works, quake_engine_analysis}

    V novém tisíciletí se zlepšovalo vše, co se doposud vynalezlo. Renderovací algoritmy mohli býti
    více realisticé kvůli zlepšení \gls{gpu}.
    
    Společně s vývojem počítačové grafiky začaly vznikat i první videohry. Hra Spacewar! byla
    jedna z prvních, která se rozšířila po laboratoř9ch na amerických univerzitách. Hru 
    vytvořil na MIT Steve Russell a jeho přátelé v roce 1962. Hra byla vytvořena pro dva hráče,
    každý ovládal svou loď a jeho cílem bylo sestřelit loď protihráče. Lodě byly ovládány speciálním
    boxem, který se dá považovat za předchůdce moderních herních kontrolerů. Hra běžela na počítači
    PDP-1, který namísto rasterové grafiky využíval grafiku vektorovou.
    Věci vykreslené na osciloskopu byly definované matematickou funkcí.
    Díky tomu, že vektorová grafika nebyla tolik náročná na \gls{cpu}
    jako rasterová, mohla ve hře být hvězda, která svojí gravitací působila na lodě.
    \cite{spacewar, vector_graphics, spacewar_controllers}

\section{Grafické karty}
\subsection{CPU vs. GPU}
    Tradičně běžela většina apklikací sekvenčně, které běží na procesorech, které
    mají centrální výpočetní jednotku a provádí instrukce
    jednu po druhé \gls{cpu}. V průběhu 20. století se výkon \gls{cpu} významě zlepšoval až na
    bilion operací za sekundu, čímž se mohli zlepšévat grafické aplikace a využívat náročnější
    funkce. Na přelomu tisíceletí se ale vývoj začal zpomalovat, kvůli problému se spotřebou
    energie a odvodem tepla. Proto výrobci začali vytvářet \gls{cpu} s více jádry, ale ani to nebylo
    dostatečně výkonné na složíté výpočti, a proto už v sedmdesátých a osmdesátých
    letech začali vznikat počítače které nepracovali sekvenčně, ale paralelně. V devadesátých
    letech se
    začali vytvářet mikroprocesory, které se soustředili na paralelní výpočty \gls{gpu}. V průběhu
    let se počet jader z jednotek dostal na tisíce, což vytvořilo prostor pro inovaci v grafice.
    \cite{programming_massively_parallel_processors}

    Prvně bylo \gls{gpu} pouze v počítačích specializovaných pro 3D hry a vizualizace, ale postupně
    se stala součástí každého počítače. \gls{gpu} a \gls{cpu} se používá v různých případech kvůli
    rozdílné architektuře. \gls{cpu} má jednotky až desítky jader a umí dělat jeden krok extrémě
    rychle kvůli sekvenčnímu zapojení.
    Velká část čipu je určena pro cachi, tedý malu pamět, kam se ukládají data která budou 
    pravděpodobně v budoucnisti potřeba, takže není potřeba komunikovat neustále s \gls{ram}.
    Část čipu je také pro control logiku, která dokáže instrukce z jednoho vlákna dělat paralelně
    nebo na jiném sekvenčním pořadí, ale zachovat sekvenčnost celého procesu. \gls{cpu} má také
    menší propustnost paměti než \gls{gpu}, proto jsou cache-friendly programy výrazně rychlejší.
    Narozdíl od toho má \gls{gpu} stovky až tisíce jader.
    Kontrolní logika a cache jsou v jádru menší a jednodužší, 
    takže velmi pomalu reaguje na
    události a po dokončení operaí se většinou data vrací zpět do virtual random access memory
    \gls{vram}, což je díky velké
    propustnosti i pro velmi velký objem dat rychlé.
    \cite{programming_massively_parallel_processors}

    Do roku 2007 se \gls{gpu} pouzival prevazne pro renderovani, ale v roce 2007 prisla NVIDIA s
    programovacim modelem pro paralelni vypocty CUDA. Tento model umoznuje psat programy, ktere
    bezi na \gls{gpu} a vyuzivaji \gls{cpu} na prenost dat a rizeni techto programu. 
    Diky tomu mohli zacit vznikat aplikace, ktere normalne bezi na \gls{cpu}, ale pri potrebe
    narocnejsich pocetnich operaci mohly bezet na \gls{gpu}, a tim
    zvysit vykon. Pro ucel vysvetleni programovacich modelu pro paralelni vypocty budu vyuzivat
    model CUDA, pricemz existuji i jine podobne modely jako OpenCL nebo SYCL.
    \cite{programming_massively_parallel_processors}

\subsection{Architektura a paměťová hierarchie GPU}

    \gls{gpu} s podporou CUDA je organizovano do pole paralelnich streamovacich multiprocesoru
    \gls{sm}. Kazdy \gls{sm} se sklada z nekolika streamovacich procesoru \gls{sp}, ktere jsou
    zakladni vypocetni jednotkou, na ktere probihaji aritmeticke operace. Dalsi soucasti jsou ridici
    jednotky, ktere nacitaji instrukce pro dany \gls{sm}. Ridici jednotky taky obsahuji malou
    cache na instrukce, aby se pro ne meuselo porad sahat do \gls{ram}. Dale je unvintr \gls{sm} warp
    scheduler, ktery ridi ktere zkupiny vlaken budou v kazdem cyklu pouzity.
    \cite{programming_massively_parallel_processors}

    Vetsina grafickych karet ma svoji vlastni dynamic random access memory \gls{dram}, ktere se rika
    globalni pamet. V grafickych kartach je specificky typ \gls{dram} zvany \gls{vram}. Tato pamet ma
    jednotky az desitky gigabytu. Dochazi v ni k vymene dat mezi host memory. Rychla vymena dat
    mezi host memory a \gls{vram} je zarucena velkou propustnosti, ktera je zpusobena nacitanim
    dat blokove namisto sekvencne a take posilanim vetsiho objemu dat najednou. \gls{vram} je zdilena
    mezi vsemy \gls{sm}, ale pristup k ni je relativne pomaly. Dalsi pameti je shared memory, ktera
    ma vetsinou desitky kilobajtu. Tuto pamet ma kazdy \gls{sm}, a kazdy \gls{sp} si do ni muze
    sahat. V kazdem \gls{sm} se takze vyskytuje L1 cache, ktera slouzi k uchovavani dat, ze ktercyh se
    nedavno cetlo nebo byla zmenena. Dale existuje L2 cache, ktera je vetsi nez L1 cache, a je
    jedna pro vsechny \gls{sm}. Pouziva se pro uchovavani dat nedavno ziskana nebo poslana do
    \gls{vram}. Cast \gls{vram} je take urcena pro dva jine typy pameti a to texture a constant
    memory. Obe pameti maji k sobe prirazenou svoji
    cache a jsou read-only. Tim ze jsou read-only, muzeme casto pouzivane hodnoty uchovavat v cachi
    bez obavy z toho, ze by se dana promena mohla v prubehu zmenit. Nejmensi, ale take nejrychlejsi
    casti pamety jsou register files. Tato pamet primo komunikuje s \gls{sp} a ukladaji se do ni
    docasne promene a mezivypocty.
    \cite{programming_massively_parallel_processors, memory_hierarchy_of_gpu, memory_types_of_gpu}
    \begin{figure}[H]
        \includegraphics[width=\linewidth]{GPU_architecture.png}
        \caption{Typická architektura NVIDIA \gls{gpu} \cite{gpu_image_source}}
    \end{figure}

\subsection{Paralelismus}
    Paralelismus je vypocetni technika, ktera umoznuje vykonavani vice operaci najednou. Paralelismus
    se da rozdelit do dvou kategorii. Prvni z nich je ulohovy paralelismus. Tento typ nasleduje
    Multiple Insturctions, Multiple Data (MIMD) model. Tento model rozdeli ruzne ulohy mezi vice
    vlaken nebo i jader. Tento model se vyuziva, pokud na sobe nejsou ulohy zavisle. Pokud by se
    napriklad chtela vypocitat suma arraye, muze kazde vlakno pocitat jednu polovinu a dva vysledky
    secist. MIMD se vyuziva v simulacich nebo na webovych aplikacich.
    \cite{programming_massively_parallel_processors, types_of_parallelism}

    Druhou metodou je data paralelismus, ktery je definovan Single Instruction, Multiple Data (SIMD)
    modelem. Tento model aplikuje jedno ulohu pro velke mnozstvi dat a vyuziva se v \gls{gpu}.
    Pouziva ne napriklad pri nasobeni matic, kde se dana matice da rozdelit na mensi casti nebo
    pri vykreslovani, kdy se jeden shader aplikuje pro kazdy pixel. V grafickych kartach se
    jednotliva vlakna sdruzuji do warpu, ty dale do bloku, ktere planuje \gls{sm}. Do kazdeho warpu
    jsou nactene stejne instrukce a postupne se se mu dodavaji data, na kterych dane instrukce
    provadi. Diky tomu lze i velke mnozstvi dat zpracovat velmi rychle, protoze se dodavaji s velkou 
    propustnosti a instrukce na nich jsou provadeny soucasne na velkem mnozstvi warpu.
    \cite{programming_massively_parallel_processors, types_of_parallelism}

    \begin{figure}[H]
        \includegraphics[width=\linewidth]{vlakna_v_sm.png}
        \caption{Rozělení vláken do warpu v \gls{sm} \cite{programming_massively_parallel_processors}}
    \end{figure}
\section{Grafická zobrazovací pipeline}
    Hlavni funkci graficke zobrazovaci pipeline je vyrenderovat dvourozmerny obraz z trojrozmernych
    objektu, pozice virtualni kamery, zdroju svetla atd., ktery je schopen byt zobrazen 
    na napriklad monitoru. Pipeline se sklada z
    nekolika fazi. Tyto faze probihaji paralelne v ramci jednotlivych fazi, tedy jedna faze probiha
    pro vice dat najednou, tak i mezi jednotlivymi fazemi, takze pro pruchodu jednoho bloku dat
    jednou fazi prechazi do dalsi faze, i kdyz pro jina data jeste predchozi faze nemusi byt 
    ukoncena. Hlavni ctyri faze jsou aplikacni faze, geometricke zpracovani, rasterizace a zpracovani
    pixelu.
    \cite{real_time_rendering}

    Aplikacni faze je rizena samotnou aplikaci a je vetsinou implementovana jako software bezici
    na \gls{cpu}. Tato faze nema zadne podprvky, a proto muze bezet paralelne na ruznych jadrech.
    V teto casti se zpracovavaji vztupy od uzivatele, ktere napriklad pozmenuji matici k posunuti,
    otoceni nebo zmeny velkikosti ruznych objektu. V teto casti take dochazi detekce kolizi,
    akceleracni algoritmy, fyzikalni simulace a dalsi vypocty, ktere pripravuji data pro dalsi
    scenu.
    \cite{real_time_rendering}

    Dalsi casti pipeliny je geometricke zpracovani. Ta jo zodpovedna za vetsinu operaci pro kazdy
    trojuhelniky a vrcholy, ktere tvori objetky. Rozdeluje se na ctyri podfaze, vertex shading,
    projekce, clipping a screen mapping. Vertex shading vypocitava pozici vrcholu a pripravuje jeho
    data jako barvy a textury. Objekt je transformovan z modeloveho prostoru do svetovych souradnic,
    tedy souradnic relevantni pro vsechny objekty ve scene. Dale se to transformuje do kameroveho
    prosotru, ve kterym je kamera v bode nula. Pote dochazi k projekce, kdy dochazi k transformaci
    z kameroveho prostoru do clip spacu, aby bylo mozne provezt clipping. Clipping urcuje, jaky
    objekt se budou renderovat. 
    Pokud by napriklad cely objekt byl mimo zorne pole sceny, neni renderovan,
    aby zbytecne nezatezoval \gls{gpu}. Posledni casti je mapovani na obrazovku, ktera prevede
    souradnice z clip spacu do souradnic obrazovky, pripravene pro rasterrizaci.
    Soucasti vertex shadingu jsou take volitelne faze vertex zpracovani. Tessellation generuje
    vhodne trojuhelniky pro zakrivene povrchy, aby vypadali
    realisticneji. Geometry shader umoznuje podle potreby vytvaret nove vrcholy
    z existujicich trojuhelniku nebo bodu, coz se pouziva napriklad u malych castic, aby byli
    lepe videt na obrazovce, 
    takze se z nej udela napriklad maly ctverec. Posledni volitelna faze je stream output,
    ktera umoznuje namisto poslani vrcholu do dalsi faze ulozit vrcholy do bufferu, na kterych
    \gls{cpu} muze delat dalsi vypocty ci simulace. 
    \cite{real_time_rendering}

    Nasledujici faze je restarizace, jejiz ucel je nalezt vsechny pixely uvnitr vykreslovaneho
    trojuhelniku. Restarizace se deli na pripravu trojuhelniku a pruchod trojuhelnikem. Pri priprave
    se vypocitavaji diferencialy, rovnice hran a jina podobna data, ktera jsou vyuzivana k zjistovani
    zda dany pixel lezi uvnitr trojuhelniku. Pri pruchodu se zjistuje, zda stred pixelu lezi uvnitr
    trojuhelniku a pokud ano, vytvori se pro dany pixel fragment. Vlastnosti, jako barva, hloubka atd.
    jednotlivych fragmentu se ziskavaji interpolaci mezi vrcholy daneho trojuhelniku a
    nasledne se ukladaji do specificych bufferu. Vysledne
    fragmenty jsou nasledne predany do faze pixeloveho zpracovani.
    \cite{real_time_rendering}

    Pixelove zpracovani se deli na pixelove stinovani a slucovani. Ve fazi pixeloveho stinovani
    se provadeji vypocty stinovani jednotlivych pixelu z stinovacich dat. Vysledkem je jeden nebo
    vice barevnych vystupu. V teto fazi se pouziva hodne specifickych
    technik, jako napriklad texturovani.
    Pixelove stinovani je narozdil od ostatnich fazi, ktere jsou dany architekturou \gls{gpu},
    dano programovatelnymy jadry \gls{gpu}. Pri slucovani dochazi k kombinaci vyztupu pixeloveho
    stinovani a ulozenych barev v bufferech. V teto fazi se take resi viditelnost, aby se
    vykreslovalal pro dany pixel fragment s nejmensi hloubkou.
    \cite{real_time_rendering}

\section{Transformace}
    V prubehu renderovani je casto potreba s objekty ruzne pohybovat. Mohli bychom pozmenovat
    souradnice puvodnich vrcholu a opetovne konfigurovat jejich buffery, ale to je vypocetne naroce.
    Misto toho se vyuzivaji transformace pomoci matic. Matice jsou obdelnikove pole matematickych
    vyrazu. Souradnice objektu se ukladaji do 4D vektoru, a transformace do 4x4 matice, ktere se
    mezi sebou vynasobi.
    $$
    \begin{pmatrix}
    m_{00} \cdot x + m_{01} \cdot y + m_{02} \cdot z + m_{03} \cdot w \\
    m_{10} \cdot x + m_{11} \cdot y + m_{12} \cdot z + m_{13} \cdot w \\
    m_{20} \cdot x + m_{21} \cdot y + m_{22} \cdot z + m_{23} \cdot w \\
    m_{30} \cdot x + m_{31} \cdot y + m_{32} \cdot z + m_{33} \cdot w \\
    \end{pmatrix}
    =
    \begin{pmatrix}
    m_{00} & m_{01} & m_{02} & m_{03} \\
    m_{10} & m_{11} & m_{12} & m_{13} \\
    m_{20} & m_{21} & m_{22} & m_{23} \\
    m_{30} & m_{31} & m_{32} & m_{33}
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    w
    \end{pmatrix}
    $$
    Mezi zakladni operace patri translace, rotace a skalovani. Translace je operace, pri ktere se
    k puvodnimu vektoru price jiny vektor, cimz se puvodni objekt posune.
    Potrebujeme translacni hodnoty nasobit
    slozkou w vektoru, ktera je nastavena na 1, aby neupravila tyto hodnoty. Proto pouzivame 4D
    vektor, protoze s 3D vektorem by translace nebyla mozna.
    $$
    \begin{pmatrix}
    x + T_{x} \\
    y + T_{y} \\
    z + T_{z} \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    1 & 0 & 0 & T_{x} \\
    0 & 1 & 0 & T_{y} \\
    0 & 0 & 1 & T_{z} \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    Dalsi operaci je skalovani. Pri teto operaci se dane souradnice nasobi konstantou, cimz se muze
    dany objekt zmensit nebo zvetsit. 
    $$
    \begin{pmatrix}
    S_{x} \cdot x \\
    S_{y} \cdot y \\
    S_{z} \cdot z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    S_{x} & 0 & 0 & 0 \\
    0 & S_{y} & 0 & 0 \\
    0 & 0 & S_{z} & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    Posledni dulezita operace je otaceni. Pri teto operaci zavisi na tom, podle jake osy se ma
    objekt otacet a o kolik radianu se ma otocit.

    Rotace podle osy X:
    $$
    \begin{pmatrix}
    x \\
    \cos \theta \cdot y - \sin \theta \cdot z \\
    \cos \theta \cdot y + \cos \theta \cdot z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    1 & 0 & 0 & 0 \\
    0 & \cos \theta & -\sin \theta & 0 \\
    0 & \sin \theta & \cos \theta & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    
    Rotace podle osy Y:
    $$
    \begin{pmatrix}
    \cos \theta \cdot x + \sin \theta \cdot z \\
    y \\
    -\sin \theta \cdot x + \cos \theta \cdot z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    \cos \theta & 0 & \sin \theta & 0 \\
    0 & 1 & 0 & 0 \\
    -\sin \theta & 0 & \cos \theta & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$
    
    Rotace podle osy Z:
    $$
    \begin{pmatrix}
    \cos \theta \cdot x - \sin \theta \cdot y \\
    \sin \theta \cdot x + \cos \theta \cdot y \\
    z \\
    1
    \end{pmatrix}
    =
    \begin{pmatrix}
    \cos \theta & -\sin \theta & 0 & 0 \\
    \sin \theta & \cos \theta & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
    x \\
    y \\
    z \\
    1
    \end{pmatrix}
    $$

    Pri provadeni transformaci zalezi na poradi. Pokud je pro transformaci jednoho objektu vice
    matic, pronasobi se matice mezi sebou, a pouziva se vysledna matice.
    Pri tvoreni takove matice se ale postupuje v opacnem
    poradi nasobeni. Pokud by jsme pro vektor V chteli
    udelat operace a, b a c, tak to lze udelat nasledovne:
    $$ \mathbf{V'} = \mathbf{C} \cdot (\mathbf{B} \cdot (\mathbf{A} \cdot \mathbf{V})) $$
    nebo
    $$ \mathbf{M} = \mathbf{C} \cdot \mathbf{B} \cdot \mathbf{A} $$
    $$ \mathbf{V'} = \mathbf{M} \cdot \mathbf{V} $$


\chapter{OpengGL}

\section{Historie OpenGL}
Open GL je povazovano za Application Programming Interface \gls{api}, ktera uzivatelum poskytuje sadu
funkci, kterou muzeme pouzivat k manipulaci s grafickou karou. Specifikaci pro OpenGL dela spolecnost
Khronos Group, ktera urcuje jake funkce existuji a jak se budou chovat. Pote kazda spolecnost
implementuje OpenGL API pro svuj druh grafickych karet.
\cite{learn_opengl}

\section{OpenGL pipeline}
Graficka pipeline je velmi podobrna obecne graficke pipeline, kterou jsem popisoval v predchozi
kapitole. Uzivatel je schopen kontrolovat programovatelne faze pipeline, tedy vertexovym a
fragmentovym shaderem. Casti jako rasterizace jsou nemenne a jsou definovane v API.
\cite{learn_opengl}

\section{Shadery}
\subsection{Co to je shader}
Shader je maly program, ktery bezi na \gls{gpu}. Tyto programy se spousteji pro konkretni cast
graficke pipeline. Shadery premenuji vstupy a prevadeji je na vystupy potrebne pro nasledujici faze.
Starsi verze OpenGL meli defaultni shadery, ale v novejsich verzich je uzivatel povinen vytvorit
zakladni shadery, aby \gls{gpu} neco vykreslila. Shadery jsou od sebe izolovane a komunikuji spolu
pouze pomoci vstupu a vystupu. Shaderu je vice druhu a dva zakladni jsou vertex a fragment shader.
Shadery se kompiluji a linkuji a nasledne ukladaji do pameti \gls{gpu} jako soucast shader programu.
To je objekt ktery je vysledna slinkvovana verze vice shaderu. Shader programu muze mit uzivatel vice
a pro kazdy objekt si muze vybrat jiny, podle toho jake shadery na nej chce pouzit.
\cite{learn_opengl}

\subsection{Vertex shader}
Zakladni ucel vertex shaderu je zpracovavani vrcholu objektu. Do vertex shaderu vztupuji atributy
vrcholu, jako barvy nebo 3D souradnice bodu v modelovem prostoru. Vertex shader provadi transformace
techto souradnic do svetoveho, kameroveho a nasledne clip prostoru pomoci transformacnich matic.
Vztupni data jsou ulozena v \gls{gpu}, kde k nim ma vertex shader primy pristup.
\cite{learn_opengl}

\subsection{Fragment shader}
Ucelem fragment shaderu je vypocitavani barevneho
vystupu pro pixely. Barvy se v OpenGL definuji 4D vektorem s floaty od 0.0 do 1.0. Tyto cisla udavaji
silu barev cervena, zelena a modra (RGB). Posledni cilso udava alfa hodnotu, tedy jak moc kombinace
danych tri barev bude pruhledna. Ve fragment shaderu take dochazi k texturovani a ruznym efektum jako
odlesky, stinovani atd.
\cite{learn_opengl}

\subsection{Buffery a linkování}
Vztupni data vertex shaderu se ukladaji do pameti \gls{gpu} pomoci Vertex Buffer Objektu \gls{vbo}.
Ten v sobe dokaze ulozit velke mnozstvi dat, diky cemuz jich posilame vice najednou a vyuzivame
vysokou propustnost \gls{gpu}. Tyto data jsou pak jednoduse pristupna pro vertex shader, ktery s nimi
v \gls{gpu} pracuje. Nasledne se propojuji vertex attributy. To udava, jak jsou vztupni data linknuta
k promennym uvnitr vertex shaderu. Dalsim dulezitym objektem je Vertex Array Object \gls{vao}, do
ktereho se uklada jak jsou data v VBO usporadana a jak se maji propojit s vertex shadery. 
\cite{learn_opengl} 

Shadery se kompiluji a linkuji a nasledne ukladaji do pameti \gls{gpu} jako soucast shader programu.
To je objekt ktery je vysledna slinkvovana verze vsech shaderu. Linkovani shaderu propojuje vystupy
jednoho shaderu s vstupy druheho. Shader programu muze mit uzivatel vice a pro kazdy objekt si muze
vybrat jiny, podle toho jake shadery na nej chce pouzit.
\cite{learn_opengl}

\subsection{GLSL}
Shadery se pisi v programovacim jazyce OpenGL Shading Language \gls{glsl}, ktery je podobny jazyku C.
\gls{glsl} je specificky navrzen pro praci s grafikou a obsahuje uzite funkce na manipulaci s vektory
a maticemi. Pokud jsou na sebe linknute dva shadery, vystupy z prvniho shaderu se prenesou do druheho
shaderu. Promene ovsem musi mit identicky typ a velikost. Dalsi duleztiou funkci jsou uniformy, coz
jsou globalni promene pro vsechny shadery uvnitr jednoho shader programu. V uniformach se casto
uchovavaji matice a dalsi konstanty.
\cite{learn_opengl}

\section{Textury}
Textura je obrazek pouzivany k pridavani detailu k objektu. Pro kazdy vrchol objektu priradime
souradnici textury, ktera urcuje jaka cast textury odpovida danemu vrcholu. Souradnice textury se
ukladaji do vertex atributu. Textura se pak aplikuje ve fragment shaderu na kazdy fragment objektu,
cimz se promitne. Je take mozno mit puvodni barvu objektu s jednou nebo vice texturami na jednom
objektu. Nasledne se barvy a textury pomerove mixuji podle nastavenych alpha hodnot.
\cite{learn_opengl}

\chapter{to do}
    mozna pridat trochu historie compileru u C a CPP

    celá část hirstorie počítačové grafiky je scuffed, chybí tam
    části o gpu, a nejspis to bude potreba zkratit a udelat rozdeleni do subsectionu podle let

    kdyz introdusuju zkratku, dej ji velka pismena, at ctenar vi ze je to zkratka

    predelat pomlcky z - na tu dinvou co pouziva chat a chce ji pazi

    odendej vsechny cislovky z textu a nahrad je slovama

%%%%%%%%%%%%%% PRAKTICKÁ ČÁST %%%%%%%%%%%%%%%%%%	
\clearpage
\part{Vývoj hry v OpenGL} % název praktické části (nenechávejte název Praktická část)
\chapter{Architektura hry}
Pro vytvareni sve hry jsem si vybral OpenGL, protoze je to nizkourovnove \gls{api}, jehoz pouziti
vyzaduje zakladni porozumeni graficke pipeline. Jako programovaci jazyk jsem si vybral C++, protoze
je pro C knihovnu dobre kompatibilni, ale pritom mohu vyuzivat prvky objektoveho programovani, ktere
jsou ve vyvoji hry uzitecne.

Moje hra ma dva zakladni stavy. Prvnim z nich je menu, ve kterem je uzivatel pri prvnim zapnuti hry.
Po kliknuti tlacitka play se uzivatel presouva do druheho stavu bezici hry. Pri behu hry ja cilem
hracem pohybovat kosikem a sbirat jablka, coz mi pridava skore. Zaorven je cilem hracem vyhybat se
padajicimi kokosum, ktere hracovi odebiraji zivoty. Tento stav bezi, dokud
uzivateli nedojdou vsechny zivoty a nasledne je presunut zpet do herniho menu. Hra je tvorena vetsim
poctem souboru, ktere nize vysvetlim.

\begin{itemize}
    \item main.cpp - Vytvari herni okno a spousti hlavni smycky.
    \item window.cpp - Inicializuje GLFW a spravuje okno aplikace.
    \item game.cpp - Ridi prepinani hernich stavu a resetuje promene pri restaru hry. 
    \item game\_menu.cpp - Renderuje menu stav a predava informace do hlavniho herniho menu zda byla
        hra spustena.
    \item game\_running.cpp - Renderuje stav, kdyz hra bezi a vola funkce pro objekty ve hre.
    \item shader.cpp - Spravuje shadery, tedy kompilaci, linkovani, aktivaci a nastavovani uniformu.
    \item rendering\_function.cpp - Poskituje funkce pro nacitani shaderu a propojovanim vztupnich dat
        s \gls{vbo} a \gls{vao}.
    \item texture.cpp - Spravuje vytvareni, aktivaci a nastaveni parametru textur.
    \item vertices.cpp - Uchovava vztupni data jako souradnice objektu a textur.
    \item fruit.cpp - Spravuje tvoreni, pohyb a mazani ovoce.
    \item player.cpp - Spravuje pohyb hrace.
    \item text.cpp - Spravuje vytvareni a updatovani textu na pocitani zivotu a bodu.
    \item collision\_detection.cpp - Zjistuje zda dochazi ke kolizi hrace s ovocem a pripadne vola
        update zivotu a skore.
    \item random.cpp - Vytvari nahodne doubly a floaty.
\end{itemize}

\chapter{Použité programy a knihovny}
\section{CMake}
CMake je program, ktery generuje nativni soubory build systemu pro ruzne platformy. Do textoveho
souboru CMakeLists.txt se zapisuji zdrojove soubory, path ke knihovnam ktery program pouziva a 
take configuraci verze C++, kterou chce uzivatel pouzivat. CMake tyto informace preda compileru, takze
uzivatel nemusi vypisovat pro kazdou compilaci vsechny dependencies sveho programu. 
Dalsi vyhodou je, ze build vytvoreny pomoci CMake muze fungovat napric platformami.
\cite{software_developement_with_cmake}

\section{GLAD}
GLAD je knihovna, ktera generuje loader na zaklade oficialni specifikace OpenGL. Od verze OpenGL 1.1
nejsou moderni funkce primo v systemu, takze nejdou importovat do programu jako knihova,
ale jsou implementovany v ovladacich grafickych karet. Kvuli tomu by kompiler nebyl schopen najit
deklarace techto OpenGL funkci. Kvuli tomu se vyuzivaji loadery jako GLAD, ktere nactou tyto
funkce a jake header je vlozi do C++ programu.
\cite{opengl_loading_library}

\section{GLFW}
GLFW je knihovna urcena pro vyvoj aplikaci vyuzivajici OpenGL nebo Vulkan. Hlavnim ucelem GLFW je
otevirani, sprava a vlastnosti oken. Pro kazde okno je vytvoren kontext, ktery obsahuje stav grafiky
spojeny pro dane okno. \gls{gpu} pri vykreslovani cerpa z kontextu uchovany stav, ktery funguje
jako prostrednik mezi programem a \gls{gpu}. Dalsi dulezitou funkci je zpracovavani vstupu
uzivatele jako stisk klavesy ci mysi, cimz je program schopen reagovat na interakce uzivatele s oknem.
\cite{glfw_introduction}

\section{GLM}
GLM je matematicka knihovna urcena pro graficky software. GLM poskytuje funke a tridy implementovane
stejnymy nazvy a funkcemi jako \gls{glsl}, coz usnadnuje praci s shaderama. GLM se
prevazne pouziva na praci s maticemi a obsahuje funkce pro operace s nimi, coz ulehcuje transformace
objektu jako posun ci rotaci. GLM take obsahuje generator nahodnych cisel nebo kvaterniony, ktere
slouzi k provadeni rotaci ve 3D prostoru.
\cite{opengl_mathematics}

\section{stb\_image}
Knihovna stb\_image je jednoduch knihovna pro nacitani obrazku. Dokaze zpracovat vetsinu beznych
formatu obrazku jako PNG nebo JPG. Tyto obrazky uklada jako surova data do pamert. Pro kazdy
pixel jsou ulozena 3 cisla pri pouzivani RGB nebo 4 cisla pri RGBA.

\chapter{Herní mechaniky}
\section{Generátor čísel}
Por mou hru jsem potreboval nejaky generator nahodnych cisel pro pocatecni x souradnici ovoce nebo
pro rychlost jakou bude padat. Moje class vyuziva pseudonahodny generator mt19937. Tento generator
po dodani seedu vygeneruje nahodnou sekvenci cisel. Pro vytvoreni seedu pouzijeme funkci 
random\_device, ktera vygeneruje nahodne cislo z nahodnych parametru systemu. Generovani cisel
podle parametru systemu je nahodnejsi, ale tento proces je pomerne pomaly, a proto se vyuziva
jen na generovani seedu. Pro vytvoreni cisla z nejakeho rozmezi se pouziva funkce uniform\_real\_distribution. Ten vydeli kazde vygenerovane cislo tim nejvetsim moznym vygenerovanym cislem, cimz vytvori
cislo v rozmezi od 0 do 1. Nasledne se rozmezi ktere chceme vytvorit premapuje na rozmezi od 0 do 1.
\cite{cppreference}
\section{Generování ovoce}
Pro generovani a praci s ovocem jsem si vytvoril dve pomocne struktury.
\begin{lstlisting}[caption={pomocne struktury}]
enum class FruitType
{
    apple = 0, coconut = 1
};

struct fruitAttributes
{
    FruitType type;
    glm::mat4 transform;
    float speed;
};
\end{lstlisting}
Fruit type slouzi k tomu, aby se priradila spravna textura k danemu ovoci a aby se pri kolizi pridal
bod nebo odebral zivot. Ve fruitAttributes jsou vsechny potrebne parametry pro kazde ovoce pohromade,
takze se snimi lepe pracuje. Pote si vytvorim deque, ve kterem si ukladam vsechno ovoce, ktere je
na obrazovce. Pri vytvareni ovoce vygeneruju nahodnou rychlost a matici, ve ktere je nahodne posunuti
v x souradnici. Pro mazani a kolize nasledne vzdy jen iteruju skrz vsechno ovoce, a zjistuju zda
se dostala pod hranu obrazovky a nebo kolidovali s kosikem.
\section{Vykreslovaní čísel}
Pro pocitani skore a zivotu jsem si vytvoril classu pro vykreslovani cisel. Protoze cisla ktera
potrebuji vykreslit mohou mit libovolnou hodnotu, nevyplati se pro kazde cislo vytvaret samostatnou
texturu. Misto toho jsem vyuzil techniku zvanou texture atlas. Tato technika vytvari jednu velkou
texturu s cislicemi od 0 do 9. Kazda cifra vykreslovaneho cisla je samostatny objekt, a je mu
prirazena cast textury s odpovidajici cislici.
Aby byla cislica spravne vycentrovana, musi se kazdemu objektu priradit transformaci matice. Pozice
jednotlive cislice zavisi na celkove delce vykreslovaneho cisla a take na pozici dane cisfry v cisle.
V shaderu se pomoci posunu texturovych souradnic urcuje, jaka cast textury se ma vykreslit na objekt.

\section{Detekce kolize}
Pro detekci kolizi jsou vyuzil Axis-Aligned Bounding Box (AABB) collsion detekci. Kazdy objekt
je reprezentovan dvjici bodu(horni levy roh a dolni pravy roh), ktere urcuji obdelnik zarovnany s
osami. Kolize se zjistuje porovnanim intervalu obou obdelniku na osach X a Y. Pokud dojde u abou
os k prekryvu, objekty mezi sebou koliduji.
\begin{figure}[H]
        \includegraphics[width=\linewidth]{collisions_overlap.png}
        \caption{AABB collision detection \cite{real_time_rendering}}
\end{figure}

%%%%%%%%%%%%% ZÁVĚR
\chapter*{Závěr}
\addcontentsline{toc}{chapter}{Závěr}  % přidá do TOC
	
\nocite{*}
\printbibliography					% Vytvoří seznam literatury
\addcontentsline{toc}{chapter}{Bibliografie}
\printglossary[title={Zkratky}]		% Vytvoří seznam zkratek
\listoffigures						% Vytvoří seznam obrázků
\listoftables						% Vytvoří seznam tabulek

%%%%%%%%%%%%% PŘÍLOHY - APPENDIX 	
\begin{appendices}
	\chapter{Fotky z pokusů}	
	\lipsum[1]
    	%\pitem{Fotky z pokusů}
    	%\eitem{Vlastní program}
    	%\eitem{Dokumentace}
    	%\eitem{Testovací data}
	\chapter{Příloha další }
\end{appendices}
%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%% KONEC %%%%%%%%%%%%%%%%%%%%%%%%%
